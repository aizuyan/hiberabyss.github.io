<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始于珞尘</title>
  
  <subtitle>从中二到中三</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiberabyss.github.io/"/>
  <updated>2018-04-11T16:15:24.246Z</updated>
  <id>https://hiberabyss.github.io/</id>
  
  <author>
    <name>Hongbo Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何部署多节点 Tendermint 集群</title>
    <link href="https://hiberabyss.github.io/2018/04/11/deploy-multiple-tendermint-nodes/"/>
    <id>https://hiberabyss.github.io/2018/04/11/deploy-multiple-tendermint-nodes/</id>
    <published>2018-04-11T14:47:28.000Z</published>
    <updated>2018-04-11T16:15:24.246Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在忙着搭建多节点的 TenderMint 节点, 中间遇到了一些坑, 会通过这篇博客记录下整个过程. 欢迎感兴趣的同学多多交流!</p><a id="more"></a><h1 id="基于-docker-compose-搭建"><a href="#基于-docker-compose-搭建" class="headerlink" title="基于 docker-compose 搭建"></a>基于 docker-compose 搭建</h1><p>本来是想直接在本机启动多个 <code>tendermint node</code> 节点来实现的, 后来觉得每个 node 都得设置不同的主目录, 会有点麻烦, 关键是还不能很方便地在别的环境运行.</p><p>这种搭建多节点的任务还是通过 docker 比较方便, 而且也有官方的 docker image <code>tendermint/tendermint</code>. 我们可以通过 docker-compose 来启动多个 container.</p><p>通过<a href="http://tendermint.readthedocs.io/en/master/deploy-testnets.html" target="_blank" rel="noopener">官方文档</a>我们知道启动 tendermint 集群需要下面几个步骤:</p><ul><li>每个 node 都需要通过 <code>tendermint init</code> 来进行初始化;</li><li>需要有一个包含所有 validator 节点 public key 的 <code>genesis.json</code> 文件, 然后用这个文件覆盖所有节点对应的文件; 在我们的示例中所有的节点都是 validator 节点;</li><li>通过 <code>tendermint show_node_id</code> 获取节点的 ID, 并通过参数 <code>--p2p.persistent_peers=ID1@node1:46656,ID2@node2:46656</code> 来传入种子 peer;</li></ul><p>这里想吐槽下官方文档和最新的代码不一致, 上面的最后一点中的 ID 在文档中没有提及, 但在最新版本的 tendermint 中, 这个 ID 又是必须的. 后来在 github 上提交了 issue 才知道怎么去获取这个 ID.</p><p>对应于上面环境准备需要做的工作, 我通过脚本文件 <code>./init_data.sh</code> 做了自动化的处理:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v `<span class="built_in">pwd</span>`/node1_data:/tendermint tendermint/tendermint init</span><br><span class="line">docker run --rm -v `<span class="built_in">pwd</span>`/node2_data:/tendermint tendermint/tendermint init</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Node1 ID: <span class="variable">$(docker run --rm -v `pwd`/node1_data:/tendermint tendermint/tendermint show_node_id)</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Node2 ID: <span class="variable">$(docker run --rm -v `pwd`/node2_data:/tendermint tendermint/tendermint show_node_id)</span>"</span></span><br><span class="line"></span><br><span class="line">cat node2_data/config/genesis.json | jq <span class="string">".validators |= .+ <span class="variable">$(cat node1_data/config/genesis.json | jq '.validators')</span>"</span> &gt; final_genesis.json</span><br><span class="line"></span><br><span class="line">cp ./final_genesis.json ./node2_data/config/genesis.json</span><br><span class="line">cp ./final_genesis.json ./node1_data/config/genesis.json</span><br></pre></td></tr></table></figure><p>其中打印出来的节点 ID 会在后面的 <code>docker-compose.yml</code> 文件中用到.</p><p>然后我们就可以通过 <code>docker-compose.yml</code> 启动多个 container 了, 这里我们启动两个节点:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.0'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tm_node1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">hbliu/tendermint</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">tm_node1</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">tm_node1</span></span><br><span class="line"><span class="attr">    tty:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'46667:46657'</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./node1_data:/tendermint</span></span><br><span class="line"><span class="attr">    entrypoint:</span> <span class="string">["bash",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"tendermint node --p2p.persistent_peers=d902b83f46131a80a82df2198a704889c5833284@tm_node2:46656 --moniker=`hostname` --proxy_app=kvstore --consensus.create_empty_blocks=false"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tm_node2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">tendermint/tendermint</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">tm_node2</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">tm_node2</span></span><br><span class="line"><span class="attr">    tty:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">NODE2_ID=5fc11b1d4ab4274476a2243e321e0daa47a36f3a</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'46668:46657'</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./node2_data:/tendermint</span></span><br><span class="line"><span class="attr">    entrypoint:</span> <span class="string">["bash",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"tendermint node --p2p.persistent_peers=59ef92d5c6a408a59e4a1d599a8aff0d4ef37785@tm_node1:46656 --moniker=`hostname` --proxy_app=kvstore --consensus.create_empty_blocks=false"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>接下来我们就可以通过下面的步骤来启动有两个节点的 tendermint 集群:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./init_data.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用上面脚本的输出的节点 ID 分别去替换 docker-compose.yml 文件中的节点 ID</span></span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>成功启动之后我们可以通过 <code>curl -s localhost:46667/net_info</code> 中的结果来判断两个节点有没有相互识别.</p><p>具体的代码放在了 <a href="https://github.com/hiberabyss/tendermint-deploy/tree/master/docker-compose-local" target="_blank" rel="noopener">Github</a>.</p><h1 id="通过-Kubernetes-来部署"><a href="#通过-Kubernetes-来部署" class="headerlink" title="通过 Kubernetes 来部署"></a>通过 Kubernetes 来部署</h1><p>上面基于 docker-compose 的方法一般只能在单机运行, 只适合用来做一些简单验证或搭建开发环境. 通过 Kubernetes 部署的话我们就能很方便地实现集群的部署及扩容.</p><p>部署一个 tendermint 节点大致需要下面三部分工作:</p><ul><li>初始化工作;</li><li>通过 <code>abci-cli</code> 启动应用进程;</li><li>启动 <code>tendermint node</code> 进程;</li></ul><p>对应于这三部分工作我们用一个 pod 里的三个 container 来实现:</p><ul><li><code>initContainers</code> 用来实现初始化相关的工作;</li><li>运行 <code>abci-cli</code> 的容器 <code>tm</code>;</li><li>运行 <code>tendermint node</code> 进程的容器 <code>app</code></li></ul><p>其中 <code>tm</code> 容器因为还需要给其他节点提供 ID 和 public key 信息, 所以我们还在其中启动了一个 http server, 它提供了两个接口:</p><ul><li><code>host:port/node_id</code> 输出当前 tendermint node 的 ID;</li><li><code>host:port/pub_key</code> 输出当前 tendermint node 的 public key;</li></ul><p><a href="https://github.com/hiberabyss/tendermint-deploy/blob/master/docker/tmnode_server.go" target="_blank" rel="noopener">这里</a> 是这个 http server 的代码.</p><p>我把这个 http server 加入到官方的 image 里制作了一个新的 image <code>hbliu/tendermint</code>:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tendermint/tendermint:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./tmnode_server /usr/bin/</span></span><br></pre></td></tr></table></figure><p>接着我们就可以在文件 <code>app.yaml</code> 中实现对应的 service, statefulset 了. 相关的代买也都放在了 <a href="https://github.com/hiberabyss/tendermint-deploy/tree/master/k8s" target="_blank" rel="noopener">Github</a>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://tendermint.readthedocs.io/en/master/deploy-testnets.html" target="_blank" rel="noopener">Deploy a Testnet</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在忙着搭建多节点的 TenderMint 节点, 中间遇到了一些坑, 会通过这篇博客记录下整个过程. 欢迎感兴趣的同学多多交流!&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://hiberabyss.github.io/categories/blockchain/"/>
    
    
      <category term="tendermint" scheme="https://hiberabyss.github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>Bash 里的文件描述符</title>
    <link href="https://hiberabyss.github.io/2018/04/05/shell-file-description/"/>
    <id>https://hiberabyss.github.io/2018/04/05/shell-file-description/</id>
    <published>2018-04-05T21:19:03.000Z</published>
    <updated>2018-04-06T19:29:00.663Z</updated>
    
    <content type="html"><![CDATA[<p>在 Shell 编程里经常会用到重定向操作, 它本质上是对文件描述符进行操作, 本文会对 Shell 脚本里的文件描述符做一个详细的介绍.</p><a id="more"></a><h1 id="默认标准文件描述符"><a href="#默认标准文件描述符" class="headerlink" title="默认标准文件描述符"></a>默认标准文件描述符</h1><p>每个进程启动时默认都会有三个标准的文件描述符:</p><ul><li><code>stdin</code> 0 号描述符, 代表输入设备, 进程从它读入数据;</li><li><code>stdout</code> 1 号描述符, 进程往其中写入数据;</li><li><code>stderr</code> 2 号描述符, 进程会往其中写入错误信息;</li></ul><p>这三个描述符默认是对应同一个 tty 设备, 这样我们便可以在终端中输入数据和获取进程的输出.</p><p>默认的文件描述符也是可以被替换的, 例如我们可以替换掉 stdout 到一个文件, 这样命令的输出就不是打印到终端, 而是被输出到文件中:</p><p><img src="/img/shell/shell-fd.gif" alt="stdout replacement demo"></p><p>在上面的 demo 中, 我们先是通过 <code>exec 1 &gt; /tmp/stdout</code> 把 stdout 指向了文件 <code>/tmp/stdout</code>, 紧接着我们执行了两条命令 <code>ls</code> 和 <code>pwd</code>, 可以看到此时终端已经没有了命令的输出. 当我们通过 <code>exec 1 &gt;&amp;2</code> 恢复 stdout 后, 可以发现文件 <code>/tmp/stdout</code> 里存储了之前命令的输出.</p><p>其中 <code>exec</code> 是一个 bash 内置命令, 不同于在终端中执行命令时会 fork 一个子进程, 通过 <code>exec</code> 执行的命令会直接修改当前的 shell 进程, 可以通过它执行命令来修改当前 shell 的 context.</p><p>如果你想使坏的话可以在别人的 <code>~/.bashrc</code> 里加入 <code>exec 1 &gt; /tmp/stdout</code>, 这样新开的所有的终端窗口里都看不到命令的输出, 要是因此被打概不负责 :) .</p><h1 id="文件描述符的操作"><a href="#文件描述符的操作" class="headerlink" title="文件描述符的操作"></a>文件描述符的操作</h1><p>Shell 中对文件描述符的操作由三部分组成: <code>(Left, Operation, Right)</code>:</p><ul><li>Left 可以是 0-9 的数字, 代表第 n 号文件描述符;<ul><li>Left 还可以为 <code>&amp;</code>, 表示同时操作 <code>stdout</code> 和 <code>stderr</code></li></ul></li><li>Right 可以是文件名或 0-9 的数字, 当 Right 是数字时必须要加上 <code>&amp;</code> 符号, 表示引用第 n 号文件描述符;<ul><li>Right 还可以为 <code>&amp;-</code>, 此时表示关闭 Left 描述符, 例如 <code>2&lt;&amp;-</code> 表示关闭 stderr;</li></ul></li><li>Operation 可以为 <code>&lt;</code> 或 <code>&gt;</code>;<ul><li>为 <code>&lt;</code> 时表示以读模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 0;</li><li>当为 <code>&gt;</code> 表示以写模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 1;</li><li>Operation 和 Left 之间不能有空格;</li><li>当 Right 为文件名时, Operation 和 Right 可以有空格, 否则也不能有空格;</li></ul></li></ul><p>当存在多个文件描述符的操作时, 会按照从左往右的顺序依次执行. 例如通过命令 <code>cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-</code> 就可以交换 stdin 和 stdout.</p><p>我们通过下面的例子来验证上面的文件描述符交换是否生效:</p><ul><li>首先把默认的 stderr 重定向到文件 <code>/tmp/stderr</code> 中, 这样在终端中就不会看到错误输出了;</li><li>当交换完 stderr 和 stdout 后, 我们就可以在 <code>/tmp/stderr</code> 文件中看到命令的正常输出了;</li></ul><p>让我们来开始实验吧:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  test exec 2&gt; /tmp/stderr</span><br><span class="line">➜  test ls</span><br><span class="line">a.txt</span><br><span class="line">➜  test ls 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-</span><br><span class="line">➜  test cat /tmp/stderr</span><br><span class="line">a.txt</span><br></pre></td></tr></table></figure><p>和我们的预期时一致的!</p><h2 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h2><ul><li><p>用文件重载 stdin :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> cat 0&lt; a.txt</span><br><span class="line">hello</span><br><span class="line">➜  <span class="built_in">test</span> cat &lt; a.txt <span class="comment"># same with last command</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li><li><p>把 stderr 和 stdout 都过滤掉</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls not_exist 1&gt; /dev/zero 2&gt;&amp;1</span><br><span class="line"><span class="comment"># another way</span></span><br><span class="line">ls not_exist &amp;&gt; /dev/zero</span><br></pre></td></tr></table></figure></li><li><p>处理上一个命令的错误输出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ls not_exist 2&gt;&amp;1 | sed <span class="string">'s/not_exist/error/g'</span></span><br><span class="line">ls: error: No such file or directory</span><br><span class="line"><span class="comment"># another way</span></span><br><span class="line">➜  blog git:(hexo) ls not_exist |&amp; sed <span class="string">'s/not_exist/error/g'</span></span><br><span class="line">ls: error: No such file or directory</span><br></pre></td></tr></table></figure></li><li><p>把标准输出转入到错误输出上: <code>echo hello 1&gt;&amp;2</code></p></li></ul><h1 id="Process-Substitution"><a href="#Process-Substitution" class="headerlink" title="Process Substitution"></a><a href="https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html" target="_blank" rel="noopener">Process Substitution</a></h1><p>在 bash 中提供了两个特殊的操作, 它们都可以被直接当成文件名使用:</p><ul><li><code>&lt;(cmd)</code> : 可以看作时一个可读文件, <code>cmd</code> 命令的输出是这个文件的内容;</li><li><code>&gt;(cmd)</code> : 可以看作时一个可写文件, <code>cmd</code> 会接受输入并进行处理;</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>利用 <code>&lt;(cmd)</code> 来验证一对公私钥是否匹配:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) diff &lt;(ssh-keygen -y -e -f ~/.ssh/id_rsa) &lt;(ssh-keygen -y -e -f ~/.ssh/id_rsa.pub)</span><br><span class="line">➜  blog git:(hexo)</span><br></pre></td></tr></table></figure><p>利用 <code>&gt;(cmd)</code> 来对错误信息进行处理, 同时保证错 stderr 信息不回变成 stdout:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ls not_exist 2&gt; &gt;(sed <span class="string">'s/not_exist/keep_error/g'</span>)</span><br><span class="line">ls: keep_error: No such file or directory</span><br><span class="line">➜  blog git:(hexo)</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://mixedvolume.blogspot.com/2004/12/file-descriptors-in-bourne-shell.html" target="_blank" rel="noopener">File Descriptors in Bourne shell</a></li><li><a href="https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html" target="_blank" rel="noopener">Process Substitution</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Shell 编程里经常会用到重定向操作, 它本质上是对文件描述符进行操作, 本文会对 Shell 脚本里的文件描述符做一个详细的介绍.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="shell" scheme="https://hiberabyss.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>GDB 实现原理介绍</title>
    <link href="https://hiberabyss.github.io/2018/04/04/gdb-internal/"/>
    <id>https://hiberabyss.github.io/2018/04/04/gdb-internal/</id>
    <published>2018-04-04T20:46:08.000Z</published>
    <updated>2018-04-08T04:09:40.625Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 是调试程序的利器, 它可以在代码中设置断点, 在程序运行过程中修改变量值等. 你是不是也很好奇 GDB 是如何实现这些功能的? 本文会解答你的疑问, 并通过一些简单的代码来模拟其中的实现细节.</p><a id="more"></a><h1 id="ptrace-介绍"><a href="#ptrace-介绍" class="headerlink" title="ptrace 介绍"></a>ptrace 介绍</h1><p>GDB 中的魔法般的操作底层都是通过 ptrace 调用来实现的, 在介绍 GDB 的具体实现细节前, 我们先来好好了解下 ptrace 调用.</p><p>从名字就可以看出 ptrace 系统调用是用于进程跟踪的, 当进程调用了 ptrace 跟踪某个进程之后:</p><ul><li>调用 ptrace 的进程会变成被跟踪进程的父进程;</li><li>被跟踪进程的进程状态被标记为 <code>TASK_TRACED</code>;</li><li>发送给被跟踪子进程的信号 (SIGKILL 除外) 会被转发给父进程, 而子进程会被阻塞;</li><li>父进程收到信号后, 可以对子进程进行检查和修改, 然后让子进程继续执行;</li></ul><p>在 <code>man ptrace</code> 中可以找到 ptrace 的定义原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="keyword">pid_t</span> pid, <span class="keyword">void</span> *addr, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 <code>request</code> 参数指定了我们要使用 ptrace 的什么功能, 大致可以分为以下几类:</p><ul><li>PTRACE_ATTACH 或 PTRACE_TRACEME 建立进程间的跟踪关系;<ul><li>PTRACE_TRACEME 是被跟踪子进程调用的, 表示让父进程来跟踪自己, 通常是通过 GDB 启动新进程的时候使用;</li><li>PTRACE_ATTACH 是父进程调用 attach 到已经运行的子进程中; 这个命令会有权限的检查, non-root 的进程不能 attach 到 root 进程中;</li></ul></li><li>PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR 等读取子进程内存/寄存器中保留的值;</li><li>PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR 等修改被跟踪进程的内存/寄存器;</li><li>PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP 控制被跟踪进程以何种方式继续运行;<ul><li>PTRACE_SYSCALL 会让被调用进程在每次 进入/退出 系统调用时都触发一次 SIGTRAP; strace 就是通过调用它来实现的, 在每次进入系统调用的时候读取出系统调用参数, 在退出系统调用的时候读取出返回值;</li><li>PTRACE_SINGLESTEP 会在每执行完一条指令后都触发一次 SIGTRAP; GDB 的 nexti, next 命令都是通过它来实现的;</li></ul></li><li>PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系;<ul><li>当父进程在子进程之前结束时, trace 关系会被自动解除;</li></ul></li></ul><p>参数 pid 表示的是要跟踪进程的 pid, addr 表示要监控的被跟踪子进程的地址.</p><h1 id="GDB-断点的实现原理"><a href="#GDB-断点的实现原理" class="headerlink" title="GDB 断点的实现原理"></a>GDB 断点的实现原理</h1><p>当我们用 GDB 设置断点时, GDB 会把断点处的指令修改成 <code>int 3</code>, 同时把断点信息及修改前的指令保存起来. 当被调试子进程运行到断点处时, 便会执行 <code>int 3</code>命令, 从而产生 SIGTRAP 信号. 由于 GDB 已经用 ptrace 和调试进程建立了跟踪关系, 此时的 SIGTRAP 信号会被发送给 GDB, GDB 通过和已有的断点信息做对比 (通过指令位置) 来判断这次 SIGTRAP 是不是一个断点.</p><p>如果是断点的话, 就回等待用户的输入以做进一步的处理. 如果用户的命令是继续执行的话, GDB 就会先恢复断点处的指令, 然后执行对应的代码.</p><p>可以看到断点的实现中需要 GDB 去修改被跟踪子进程的内存 (代码也是保存在内存中的), 下面就先介绍下如何通过 ptrace 去修改子进程的内存.</p><h2 id="修改子进程内存"><a href="#修改子进程内存" class="headerlink" title="修改子进程内存"></a>修改子进程内存</h2><p>我们通过下面的例子来演示父进程如何修改子进程的内存:</p><ul><li>父进程创建子进程, 并先让子进程 sleep 一段时间以保证父进程能更早运行;</li><li>父进程通过 <code>PTRACE_ATTACH</code> 来和子进程建立跟踪关系;</li><li>父进程修改子进程的内存数据;</li><li>父进程通过调用 <code>PTRACE_CONT</code> 让子进程恢复执行;</li></ul><p>完整的代码如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(call) (&#123; int _ret = (int)(call); printf(<span class="meta-string">"%s -&gt; %d\n"</span>, #call, _ret); <span class="meta-keyword">if</span> (_ret &lt; 0) &#123; perror(NULL); &#125;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> changeme[] = <span class="string">"This is  a test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> cdata[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int64_t</span> data;</span><br><span class="line">    &#125; u = &#123; <span class="string">"Hijacked"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* child */</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Children Message: %s\n"</span>, changeme);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">"fork"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* parent */</span></span><br><span class="line">            SHOW(ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            SHOW(ptrace(PTRACE_POKEDATA, pid, changeme, u.data));</span><br><span class="line">            SHOW(ptrace(PTRACE_CONT, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Parent Message: %s\n"</span>, changeme);</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的输出是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Children Message: Hijacked a test</span><br><span class="line">ptrace(PTRACE_ATTACH, pid, 0, 0) -&gt; 0</span><br><span class="line">ptrace(PTRACE_POKEDATA, pid, changeme, u.data) -&gt; 0</span><br><span class="line">ptrace(PTRACE_CONT, pid, 0, 0) -&gt; 0</span><br><span class="line">Parent Message: This is  a test</span><br></pre></td></tr></table></figure><p>可以看出子进程中的字符串已经被修改了, 而父进程中的字符串依旧保持不变.</p><p>在调用 <code>ptrace(PTRACE_POKEDATA, pid, changeme, u.data)</code> 时, 最后一个参数实际上是按照 <code>int64_t</code> 来处理的.</p><h2 id="模拟-GDB-设置断点"><a href="#模拟-GDB-设置断点" class="headerlink" title="模拟 GDB 设置断点"></a>模拟 GDB 设置断点</h2><p>这部分原理其实很简单, 但代码实现会稍微有些复杂. 等有人有需求时再写吧… To Be Done… :)</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.csdn.net/edonlii/article/details/8717029" target="_blank" rel="noopener">ptrace运行原理及使用详解</a></li><li><a href="http://www.cnblogs.com/tangr206/articles/3094358.html" target="_blank" rel="noopener">Ptrace 详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 是调试程序的利器, 它可以在代码中设置断点, 在程序运行过程中修改变量值等. 你是不是也很好奇 GDB 是如何实现这些功能的? 本文会解答你的疑问, 并通过一些简单的代码来模拟其中的实现细节.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://hiberabyss.github.io/tags/linux/"/>
    
      <category term="gdb" scheme="https://hiberabyss.github.io/tags/gdb/"/>
    
      <category term="ptrace" scheme="https://hiberabyss.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>区块链框架 Tendermint 入门教程</title>
    <link href="https://hiberabyss.github.io/2018/04/02/tendermint-introduction-1/"/>
    <id>https://hiberabyss.github.io/2018/04/02/tendermint-introduction-1/</id>
    <published>2018-04-02T21:17:52.000Z</published>
    <updated>2018-04-03T20:39:55.703Z</updated>
    
    <content type="html"><![CDATA[<p>Tendermint 是一个模块化的区块链应用框架, 能够实现拜占庭容错 (BFT), 它主要包括两部分:</p><ul><li>Tendermint Core:<ul><li>实现了 p2p 网络; 在节点之间共享区块和交易;</li><li>实现了拜占庭容错的共识算法, 确定了不更改改的交易顺序;</li></ul></li><li>ABCI Interface, 具体的逻辑处理层, 可以基于不同的语言 (Golang, JS) 来实现; 在这一层实现交易的验证处理以及查询等操作.</li></ul><p>这两部分会分别对应两个不同的进程, Core 和 ABCI 建立了三个连接:</p><ul><li>一个用于验证交易的连接, 交易验证通过后会被广播到 mempoll 里;</li><li>一个用于区块的 proposal;</li><li>最后一个连接用于查询应用的状态;</li></ul><a id="more"></a><p>下图是两者的 Workflow:</p><p><img src="/img/tendermint/abci.png" alt="Core and ABCI communication"></p><h1 id="基于-Tendermint-的-Key-Value-存储示例"><a href="#基于-Tendermint-的-Key-Value-存储示例" class="headerlink" title="基于 Tendermint 的 Key-Value 存储示例"></a>基于 Tendermint 的 Key-Value 存储示例</h1><p>Tendermint 内置了一个 KV 存储的应用示例, 我们可以跑下这个示例.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要先安装好 <code>tendermint</code> 和 <code>abci-cli</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/tendermint/tendermint/cmd/tendermint</span><br><span class="line">go get -u github.com/tendermint/abci</span><br><span class="line">cd $GOPATH/src/github.com/tendermint/abci</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>验证是否安装成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ which tendermint</span><br><span class="line">/Users/hbliu/go/bin/tendermint</span><br><span class="line">➜  blog git:(hexo) ✗ which abci-cli</span><br><span class="line">/Users/hbliu/go/bin/abci-cli</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>初始化节点配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tendermint init</span><br></pre></td></tr></table></figure><p>启动 KV 存储应用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abci-cli kvstore</span><br></pre></td></tr></table></figure><p>启动 Tendermint 节点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tendermint node --consensus.create_empty_blocks=false</span><br></pre></td></tr></table></figure><p>其中后面的参数是禁止 Tendermint 节点定期产生空的 block.</p><h2 id="创建交易"><a href="#创建交易" class="headerlink" title="创建交易"></a>创建交易</h2><p>在 Tendermint 中创建 key 为 <code>name</code>, value 为 <code>hbliu</code> 的存储:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ curl -s &apos;localhost:46657/broadcast_tx_commit?tx=&quot;name=hbliu&quot;&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;&quot;,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;check_tx&quot;: &#123;</span><br><span class="line">      &quot;fee&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;deliver_tx&quot;: &#123;</span><br><span class="line">      &quot;tags&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: &quot;YXBwLmNyZWF0b3I=&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;amFl&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: &quot;YXBwLmtleQ==&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;bmFtZQ==&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;fee&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hash&quot;: &quot;BA0C60A3F391B35DEAE8A7E6E0491E9B2E0BA497&quot;,</span><br><span class="line">    &quot;height&quot;: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 Response 中的 key 和 value 使用了 base64 进行了编码, 我们可以通过命令 <code>base64</code> 对其进行解码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ echo &quot;YXBwLmtleQ==&quot; | base64 -D</span><br><span class="line">app.key</span><br><span class="line">➜  blog git:(hexo) ✗ echo &quot;bmFtZQ==&quot; | base64 -D</span><br><span class="line">name</span><br></pre></td></tr></table></figure><p>查询下我们之前的信息有没有成功写入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ curl -s &apos;localhost:46657/abci_query?data=&quot;name&quot;&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;&quot;,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;response&quot;: &#123;</span><br><span class="line">      &quot;log&quot;: &quot;exists&quot;,</span><br><span class="line">      &quot;index&quot;: &quot;-1&quot;,</span><br><span class="line">      &quot;key&quot;: &quot;bmFtZQ==&quot;,</span><br><span class="line">      &quot;value&quot;: &quot;aGJsaXU=&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">➜  blog git:(hexo) ✗ echo &quot;bmFtZQ==&quot; | base64 -D</span><br><span class="line">name</span><br><span class="line">➜  blog git:(hexo) ✗ echo &quot;aGJsaXU=&quot; | base64 -D</span><br><span class="line">hbliu</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <code>http://localhost:46657</code> 可以显示当前所有支持的 API.</p><h1 id="示例代码介绍"><a href="#示例代码介绍" class="headerlink" title="示例代码介绍"></a>示例代码介绍</h1><p>上述示例的代码存储在 <a href="https://github.com/tendermint/abci/blob/master/example/kvstore/kvstore.go" target="_blank" rel="noopener">Github</a> 上. 下面我们对这部分代码做一个简单的介绍.</p><p>在我们调用 <code>broadcast_tx_commit</code> 的时候, 会先调用 <code>CheckTx</code>, 验证通过后会把 TX 加入到 mempool 里. 在 kvstore 示例中没有对 transaction 做检查, 直接通过:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *KVStoreApplication)</span> <span class="title">CheckTx</span><span class="params">(tx []<span class="keyword">byte</span>)</span> <span class="title">types</span>.<span class="title">ResponseCheckTx</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ResponseCheckTx&#123;Code: code.CodeTypeOK&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放到 mempool 里的 TX 会被定期广播到所有节点. 当 Tendermint 选出了 Proposal 节点后, 它便会从 mempool 里选出一系列的 TXs , 将它们组成一个 Block, 广播给所有的节点. 节点在收到 Block 后, 会对 Block 里的所有 TX 执行 <code>DeliverTX</code> 操作, 同时对 Block 执行 <code>Commit</code> 操作.</p><p>我们调用 <code>broadcast_tx_commit</code> 返回的结果其实就是 <code>DeliverTX</code> 返回的结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *KVStoreApplication)</span> <span class="title">DeliverTx</span><span class="params">(tx []<span class="keyword">byte</span>)</span> <span class="title">types</span>.<span class="title">ResponseDeliverTx</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> key, value []<span class="keyword">byte</span></span><br><span class="line">parts := bytes.Split(tx, []<span class="keyword">byte</span>(<span class="string">"="</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">2</span> &#123;</span><br><span class="line">key, value = parts[<span class="number">0</span>], parts[<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key, value = tx, tx</span><br><span class="line">&#125;</span><br><span class="line">app.state.db.Set(prefixKey(key), value)</span><br><span class="line">app.state.Size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tags := []cmn.KVPair&#123;</span><br><span class="line">&#123;[]<span class="keyword">byte</span>(<span class="string">"app.creator"</span>), []<span class="keyword">byte</span>(<span class="string">"jae"</span>)&#125;,</span><br><span class="line">&#123;[]<span class="keyword">byte</span>(<span class="string">"app.key"</span>), key&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> types.ResponseDeliverTx&#123;Code: code.CodeTypeOK, Tags: tags&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它会从输入参数中解析出 key 和 value, 最后保存在应用的 State 中.</p><p>当所有的 TX 被处理完之后需要调用 <code>Commit</code> 来更新整个区块的状态, 包括高度加 1 等:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *KVStoreApplication)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">types</span>.<span class="title">ResponseCommit</span></span> &#123;</span><br><span class="line"><span class="comment">// Using a memdb - just return the big endian size of the db</span></span><br><span class="line">appHash := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">binary.PutVarint(appHash, app.state.Size)</span><br><span class="line">app.state.AppHash = appHash</span><br><span class="line">app.state.Height += <span class="number">1</span></span><br><span class="line">saveState(app.state)</span><br><span class="line"><span class="keyword">return</span> types.ResponseCommit&#123;Data: appHash&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://tendermint.readthedocs.io/projects/tools/en/develop/introduction.html" target="_blank" rel="noopener">Tendermint Introduction</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tendermint 是一个模块化的区块链应用框架, 能够实现拜占庭容错 (BFT), 它主要包括两部分:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Tendermint Core:&lt;ul&gt;&lt;li&gt;实现了 p2p 网络; 在节点之间共享区块和交易;&lt;/li&gt;&lt;li&gt;实现了拜占庭容错的共识算法, 确定了不更改改的交易顺序;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ABCI Interface, 具体的逻辑处理层, 可以基于不同的语言 (Golang, JS) 来实现; 在这一层实现交易的验证处理以及查询等操作.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两部分会分别对应两个不同的进程, Core 和 ABCI 建立了三个连接:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个用于验证交易的连接, 交易验证通过后会被广播到 mempoll 里;&lt;/li&gt;&lt;li&gt;一个用于区块的 proposal;&lt;/li&gt;&lt;li&gt;最后一个连接用于查询应用的状态;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://hiberabyss.github.io/categories/blockchain/"/>
    
    
      <category term="tendermint" scheme="https://hiberabyss.github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>「Git」底层存储原理详解</title>
    <link href="https://hiberabyss.github.io/2018/03/28/git-internal/"/>
    <id>https://hiberabyss.github.io/2018/03/28/git-internal/</id>
    <published>2018-03-28T14:46:04.000Z</published>
    <updated>2018-03-29T21:48:31.367Z</updated>
    
    <content type="html"><![CDATA[<p>本文尝试通过一个示例去详细介绍 git 的底层存储的实现原理.</p><a id="more"></a><h1 id="存储原理介绍"><a href="#存储原理介绍" class="headerlink" title="存储原理介绍"></a>存储原理介绍</h1><p>Git 的底层存储从本质上讲是基于本地文件系统实现的 Key-Value 数据库. 这里的 Value 是 git 里的三种不同的对象的内容, 而 Key 则是对象内容的 hash 值.</p><p>Git 把 Key 存储为目录加文件名 (hash 值的前两位为目录名, 剩余部分作为文件名), Value 则被存储为文件内容, 默认使用了 zlib 进行压缩. 把 Key 的一部分存储为目录是为了加快文件的定位, 在查找文件时先找到对应的目录, 再遍历目录中的文件进行查找.</p><h2 id="三种不同对象类型"><a href="#三种不同对象类型" class="headerlink" title="三种不同对象类型"></a>三种不同对象类型</h2><p>Git 中有 commit, tree, blob 三种不同的对象. 其中:</p><ul><li>commit 对象存储 git 中的提交信息;</li><li>tree 对象存储 git 仓库中的文件元数据信息, 包括文件名及目录结构信息等;</li><li>blob 则对应的是 git 仓库中的文件内容;</li></ul><p>三种不同的对象可以借用 go 语言的 struct 来描述他们的结构, 这里我们其实可以把 Key 看作是一种指针:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commit object</span></span><br><span class="line"><span class="keyword">struct</span> Commit &#123;</span><br><span class="line">   Parent []*Commit</span><br><span class="line">   RootTree *Tree</span><br><span class="line">   Author People</span><br><span class="line">   Committer People</span><br><span class="line">   Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> People &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Email <span class="keyword">string</span></span><br><span class="line">   Timestamp time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tree object</span></span><br><span class="line"><span class="keyword">struct</span> Tree &#123;</span><br><span class="line">   Files []FileMeta</span><br><span class="line">   SubDirs []*Tree</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> FileMeta &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   FileData *Blob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// blob object</span></span><br><span class="line"><span class="keyword">struct</span> Blob &#123;</span><br><span class="line">   data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是对 git 底层存储结构的介绍, 还是很简单的, 下面我们以一个例子来详细介绍具体的工作原理.</p><h1 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h1><p>创建目录 GitInternal 并执行 <code>git init</code>, 添加文件 a.txt :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) ✗ <span class="built_in">echo</span> <span class="string">'file a'</span> &gt; a.txt</span><br></pre></td></tr></table></figure><p>执行 <code>git add a.txt</code>, 这时我们就可以在 <code>.git/objects</code> 中看到下面的目录结构:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── 4e</span><br><span class="line">│   └── f30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><p>通过 git 的底层命令查看这个新产生的文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  objects git:(master) git cat-file -p 4ef30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">file a</span><br></pre></td></tr></table></figure><p>通过 <code>git commit</code> 新建一个 commit 之后, 我们再查看下 commit 对象的内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) ✗ git commit -m <span class="string">'first commit'</span></span><br><span class="line">[master (root-commit) 0e79428] first commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 a.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 0e79428</span><br><span class="line">tree 63bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">author Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522355183 -0400</span><br><span class="line">committer Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522355183 -0400</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure><p>因为是第一个 commit, 所以没有 parent commit. 这时我们可以查看下 tree 对象的内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p 63bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">100644 blob 4ef30bbfe26431a69c3820d3a683df54d688f2ec    a.txt</span><br></pre></td></tr></table></figure><p>这时我们再查看 <code>.git/objects</code> 目录下的内容, 会发现和上面提到的三个对象是一一对应的:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── 0e</span><br><span class="line">│   └── 794285e05b7ca9f51afb77ace3aed310dc12dc</span><br><span class="line">├── 4e</span><br><span class="line">│   └── f30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">├── 63</span><br><span class="line">│   └── bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><h2 id="pack-文件"><a href="#pack-文件" class="headerlink" title="pack 文件"></a>pack 文件</h2><p>在原始的 git 存储模型中, 我们可以把 commit 看作是仓库在某个时间点的一个快照. 对于每一次修改, 我们都保存的是文件的完整内容, 而不是 diff. 例如当我们修改文件 <code>a.txt</code> 再重新提交之后:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) <span class="built_in">echo</span> <span class="string">'append'</span> &gt;&gt; a.txt</span><br><span class="line">➜  GitInternal git:(master) ✗ git commit -am <span class="string">'append a.txt'</span></span><br><span class="line">[master 2b5a159] append a.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>我们可以看到修改后的文件是被完整地保存为一个 blob 文件的:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p 2b5a159</span><br><span class="line">tree 454e5d08e9d43d159488f9d22664cabb31c25dd1</span><br><span class="line">parent 0e794285e05b7ca9f51afb77ace3aed310dc12dc</span><br><span class="line">author Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522356108 -0400</span><br><span class="line">committer Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522356108 -0400</span><br><span class="line"></span><br><span class="line">append a.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 454e5d08e9d43d159488f9d22664cabb31c25dd1</span><br><span class="line">100644 blob 5d17781b0c79efe46af70749fe6d6bc14bc11854    a.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 5d17781b0c79efe46af70749fe6d6bc14bc11854</span><br><span class="line">file a</span><br><span class="line">append</span><br></pre></td></tr></table></figure><p>同时原来的对象文件也都存在:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── 0e</span><br><span class="line">│   └── 794285e05b7ca9f51afb77ace3aed310dc12dc</span><br><span class="line">├── 2b</span><br><span class="line">│   └── 5a1590b3fb9727000e0265dd8d14d07fad8578</span><br><span class="line">├── 45</span><br><span class="line">│   └── 4e5d08e9d43d159488f9d22664cabb31c25dd1</span><br><span class="line">├── 4e</span><br><span class="line">│   └── f30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">├── 5d</span><br><span class="line">│   └── 17781b0c79efe46af70749fe6d6bc14bc11854</span><br><span class="line">├── 63</span><br><span class="line">│   └── bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br><span class="line">8 directories, 6 files</span><br></pre></td></tr></table></figure><p>如果每修改一次文件都要保存完整的一份, 存储空间利用率会变得很低, git 仓库的大小也会很快增大到不可忍受的地步. 对此, git 的解决方案是定期或者在特定条件下 (例如 push 的时候) 对对象文件进行打包处理.</p><p>打包的时候, git 会查找命名及大小相近的文件, 然后保存最新的文件的完整内容, 历史文件则按照 diff 的方式进行保存.</p><p>我们可以通过 <code>git gc</code> 来手动触发打包过程以观察它的工作机制:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  objects git:(master) git gc</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── info</span><br><span class="line">│   └── packs</span><br><span class="line">└── pack</span><br><span class="line">    ├── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.idx</span><br><span class="line">    └── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.pack</span><br></pre></td></tr></table></figure><p>可以看到执行完 <code>git gc</code> 之后, 原来的 blob 文件都不存在了, 但在 pack 目录里生成了两个新的文件. 其中 <code>.pack</code> 后缀文件存储的是打包前对象文件的实际内容, 而 <code>.idx</code> 后缀文件存储的是 各对象文件在 <code>.pack</code> 文件中的 index 值.</p><p>我们可以通过下面的命令来查看 pack 文件中包含的对象文件内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  pack git:(master) git verify-pack pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.idx -v</span><br><span class="line">2b5a1590b3fb9727000e0265dd8d14d07fad8578 commit 223 156 12</span><br><span class="line">0e794285e05b7ca9f51afb77ace3aed310dc12dc commit 175 124 168</span><br><span class="line">5d17781b0c79efe46af70749fe6d6bc14bc11854 blob   14 23 292</span><br><span class="line">454e5d08e9d43d159488f9d22664cabb31c25dd1 tree   33 43 315</span><br><span class="line">63bbf0e0280e60aec833588c654ced607189db7e tree   33 44 358</span><br><span class="line">4ef30bbfe26431a69c3820d3a683df54d688f2ec blob   7 16 402</span><br><span class="line">non delta: 6 objects</span><br><span class="line">pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.pack: ok</span><br></pre></td></tr></table></figure><p>其中 <code>git verify-pack -v</code> 命令的输出格式为:</p><ul><li><p>存储原始文件的对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA-1 type size size-in-packfile offset-in-packfile</span><br></pre></td></tr></table></figure></li><li><p>存储增量的对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA-1 type size size-in-packfile offset-in-packfile depth base-SHA-1</span><br></pre></td></tr></table></figure></li></ul><h2 id="包含子目录的示例"><a href="#包含子目录的示例" class="headerlink" title="包含子目录的示例"></a>包含子目录的示例</h2><p>我们在 git 库中添加子目录 <code>b</code>, 并新加一个文件 <code>b.txt</code> :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) mkdir b</span><br><span class="line">➜  GitInternal git:(master) <span class="built_in">echo</span> <span class="string">'file b'</span> &gt; b/b.txt</span><br><span class="line">➜  GitInternal git:(master) git add ./b</span><br><span class="line">➜  GitInternal git:(master) ✗ git commit -m <span class="string">'add file b.txt'</span></span><br><span class="line">[master b6651f8] add file b.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 b/b.txt</span><br></pre></td></tr></table></figure><p>我们查看最新的 tree 对象:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p b6651f8</span><br><span class="line">tree 261f921efbc41b76638aa70a63b6eca554eddf72</span><br><span class="line">parent 2b5a1590b3fb9727000e0265dd8d14d07fad8578</span><br><span class="line">author Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522359722 -0400</span><br><span class="line">committer Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522359722 -0400</span><br><span class="line"></span><br><span class="line">add file b.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 261f921efbc41b76638aa70a63b6eca554eddf72</span><br><span class="line">100644 blob 5d17781b0c79efe46af70749fe6d6bc14bc11854    a.txt</span><br><span class="line">040000 tree f2996a3c25d2f25ba05bfc4575674774e364e453    b</span><br></pre></td></tr></table></figure><p>可以发现多了一个子 tree 对象, 再查看它的内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p f2996a3c25d2f25ba05bfc4575674774e364e453</span><br><span class="line">100644 blob 4f2e6529203aa6d44b5af6e3292c837ceda003f9    b.txt</span><br></pre></td></tr></table></figure><p>在 <code>.git/objects</code> 也包含这些对象对应的文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 26</span><br><span class="line">│   └── 1f921efbc41b76638aa70a63b6eca554eddf72</span><br><span class="line">├── 4f</span><br><span class="line">│   └── 2e6529203aa6d44b5af6e3292c837ceda003f9</span><br><span class="line">├── b6</span><br><span class="line">│   └── 651f8c1101960af8192d020c0a23f124cfceca</span><br><span class="line">├── f2</span><br><span class="line">│   └── 996a3c25d2f25ba05bfc4575674774e364e453</span><br><span class="line">├── info</span><br><span class="line">│   └── packs</span><br><span class="line">└── pack</span><br><span class="line">    ├── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.idx</span><br><span class="line">    └── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.pack</span><br><span class="line"></span><br><span class="line">6 directories, 7 files</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%E5%92%8C%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">GitPro</a></li><li><a href="https://www.bittiger.io/blog/post/ExHBZfCRtGwhoYk5f" target="_blank" rel="noopener">git内部原理</a></li><li><a href="https://git-scm.com/docs/git-verify-pack" target="_blank" rel="noopener">git-verify-pack</a></li><li><a href="https://git-scm.com/book/en/v2/Git-Internals-Packfiles" target="_blank" rel="noopener">Git Internals</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文尝试通过一个示例去详细介绍 git 的底层存储的实现原理.&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://hiberabyss.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://hiberabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>「Golang」Slice 详解</title>
    <link href="https://hiberabyss.github.io/2018/03/23/golang-slice-analyze/"/>
    <id>https://hiberabyss.github.io/2018/03/23/golang-slice-analyze/</id>
    <published>2018-03-23T20:21:36.000Z</published>
    <updated>2018-03-24T14:36:42.116Z</updated>
    
    <content type="html"><![CDATA[<p>slice 是 go 里面最常用到的数据结构了, 但稍有不慎, 就会踩到一些坑. 本文会对 slice 的原理及使用通过代码的方式做一个总结和梳理.</p><a id="more"></a><h1 id="golang-的数组"><a href="#golang-的数组" class="headerlink" title="golang 的数组"></a>golang 的数组</h1><p>slice 本质上是基于数组实现的, 为了更好地理解 slice, 我们先介绍下 golang 里的数组.</p><p>golang 中的数组和 C 语言中的数组特别类似, 都是定长的同类型数据的集合. 我们可以通过 <code>[2]int {12, 8}</code> 来定义一个数组, 也可以通过另外一种形式 <code>[...]int {12, 8}</code> 来让编译器自己算出数组的实际长度.</p><p>数组的长度是不能被改变的, 我们可以通过 <code>len(array)</code> 来获取数组的长度.</p><p>数组其实可以看作一种特殊类型的 struct, 例如对于 <code>[2]int</code> 可以用类似下面的 struct 表示:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> array &#123;</span><br><span class="line">  <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个结构体, 我们可以通过 index 去访问它的成员值, 如 <code>array[0]</code> 可以访问到第一个元素.</p><p>不同于 C 语言中的数组, golang 中的数组不是指向第一个元素的指针. 当对一个数组进行赋值或者作为参数传递时, 数组会被完全复制一份, 如果把数组理解成一种特殊类型的 struct 的话, 这个行为就很好理解了.</p><h1 id="slice-的本质"><a href="#slice-的本质" class="headerlink" title="slice 的本质"></a>slice 的本质</h1><p>slice 可以看作是由三个元素组成的结构体:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> slice &#123;</span><br><span class="line">  ptr</span><br><span class="line">  <span class="built_in">len</span></span><br><span class="line">  <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ptr</code> 是指向底层数组的指针, len 表示当前 slice 中元素的数量, cap 表示当前底层数组大小.</p><p>我们用 make 来创建 slice 的时候, 最多可以指定三个参数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]Type, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中第三个参数是可选的, 用于指定底层数组的大小, 如果未指定, 则默认是和第二个参数是一致的.</p><p>用 make 创建的指定大小的数组会用类型的 0 值进行初始化, 例如对于下面的代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [0 0 2 3]</span></span><br></pre></td></tr></table></figure><p>它的输出结果是 <code>[0 0 2 3]</code>, 这是因为用 make 创建 slice 的时候, 里面已经存在了 2 个 0 值元素.</p><p>这里需要指出的一点是对 slice 的赋值操作是 O(1) 的, 它和底层数组的大小没有关系, 因为我们只需要把 (ptr, len, cap) 这三个值拷贝到新的 slice 即可.</p><h2 id="子-slice"><a href="#子-slice" class="headerlink" title="子 slice"></a>子 slice</h2><p>我们可以通过 <code>slice[begin:end:cap_idx]</code> 来获取一个子 slice, 子 slice 的大小是 <code>end - begin</code>, 其中 end 和 cap_idx 最大可以设置为 <code>cap(slice)</code>. 子 slice 相当于是:</p><ul><li>ptr = slice.ptr + begin</li><li>len = end - begin</li><li>cap = cap_idx - begin</li></ul><h2 id="slice-容量的自动扩展"><a href="#slice-容量的自动扩展" class="headerlink" title="slice 容量的自动扩展"></a>slice 容量的自动扩展</h2><p>当我们往 slice 中 append 数据时, 如果 slice 还有容量时, 直接 <code>slice[len] = newValue</code> 即可:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">_ = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">s1 := s[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [1 2]</span></span><br></pre></td></tr></table></figure><p>但如果 append 的数据超过当前 slice 的容量时, 便会重新申请一个数组存放要添加的数据. 例如我们往上面例子中的 slice 再添加一个新的数据时, 便会超过之前的容量而去重新申请一个数组. 这样之前数组里的内容便会还是默认值, 输出结果为: <code>[0 0]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">_ = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">s1 := s[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [0 0]</span></span><br></pre></td></tr></table></figure><p>当对之前的 slice 容量进行扩展时, 每次都是两倍于之前的容量, 我们可以通过下面的代码来进行验证:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceIncreaseExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cCap := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">128</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(s) != cCap &#123;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">cCap = <span class="built_in">cap</span>(s)</span><br><span class="line">&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 4 6</span></span><br><span class="line"><span class="comment">// 7 12</span></span><br><span class="line"><span class="comment">// 13 24</span></span><br><span class="line"><span class="comment">// 25 48</span></span><br><span class="line"><span class="comment">// 49 96</span></span><br><span class="line"><span class="comment">// 97 192</span></span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.go-zh.org/go-slices-usage-and-internals" target="_blank" rel="noopener">Go 切片：用法和本质</a></li><li><a href="https://studygolang.com/articles/6557" target="_blank" rel="noopener">Go语言slice的那些坑</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;slice 是 go 里面最常用到的数据结构了, 但稍有不慎, 就会踩到一些坑. 本文会对 slice 的原理及使用通过代码的方式做一个总结和梳理.&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="https://hiberabyss.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://hiberabyss.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>VIM 插件管理工具 vim-plug 简明教程</title>
    <link href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/"/>
    <id>https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/</id>
    <published>2018-03-22T01:58:39.000Z</published>
    <updated>2018-03-21T15:11:56.109Z</updated>
    
    <content type="html"><![CDATA[<p>作为 VIM 的重度患者, 一款好用的插件管理工具显得尤为重要, 毕竟给 VIM 增加新功能, 或者是新增编程语言的支持都需要安装插件. 我个人目前安装了 133 款 VIM 插件.</p><p>我使用的 VIM 插件管理工具也从早起的 Vundle 到 NeoBundle, 再到现在使用的 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a>.</p><p>选择 vim-plug , 是因为它:</p><ul><li>简洁且快速, 没有外部依赖, 整个插件只有一个文件;</li><li>该有的功能都有:<ul><li>按需加载插件(On-demand loading); 这样可以加快 VIM 启动时间</li><li>Post-update hooks; 可以在插件安装或者更新时执行一些操作, 如 make 等</li></ul></li><li>还提供了更高阶的功能, 使得安装或更新插件都更快速:<ul><li>并行化地安装或者更新插件;</li><li>按照 shallow 的方式 clone 插件库, 下载更迅速</li></ul></li></ul><p>本文是 vim-plug 的一个简明教程, 会介绍它的安装使用, 以及我个人用到的一些 tips.</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网是把 vim-plug 安装在 vim 的默认目录 <code>~/.vim</code> 中, 但我个人更喜欢把它放在一个特定的位置, 这样不管是 vim 还是 neovim 都可以正常的加载它.</p><p>下面是 linux/macOS/unix 中直接在 vimrc 中安装 vim-plug 的代码:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $BUNDLE = <span class="built_in">expand</span>(<span class="string">"$HOME/.dotfiles/data/vimdata/bundle"</span>)</span><br><span class="line"><span class="keyword">let</span> $PLUG_DIR = <span class="built_in">expand</span>(<span class="string">"$BUNDLE/vim-plug"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">empty</span>(<span class="built_in">glob</span>(<span class="built_in">expand</span>(<span class="string">"$PLUG_DIR/plug.vim"</span>)))</span><br><span class="line">  <span class="keyword">silent</span> !curl -fLo $PLUG_DIR/plug.<span class="keyword">vim</span> --create-dirs</span><br><span class="line">    \ http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/junegunn/<span class="keyword">vim</span>-plug/master/plug.<span class="keyword">vim</span></span><br><span class="line">  <span class="keyword">autocmd</span> VimEnter * PlugInstall --<span class="keyword">sync</span> | <span class="keyword">source</span> ~/.vimrc</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">source</span> $PLUG_DIR/plug.<span class="keyword">vim</span></span><br></pre></td></tr></table></figure><p>这段代码的意思是如果 <code>vim-plug.vim</code> 文件不存在, 就自动从 github 上下载最新版本到指定目录并加载.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>和大部分 vim 插件管理工具一样, vim-plug 需要一个 begin 和 end 函数, 同时在 begin 和 end 中间可以使用 <code>Plug plugin_url</code> 来加载插件, 例如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="built_in">expand</span>($BUNDLE))</span><br><span class="line"></span><br><span class="line">Plug <span class="string">'https://github.com/hiberabyss/ProjectConfig'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end() <span class="comment">" Should run at last</span></span><br></pre></td></tr></table></figure><p>把上面这部分代码放在上一步代码后面, 重新加载 vimrc <code>source ~/.vimrc</code>, 然后我们就可以使用 <code>:PlugInstall ProjectConfig</code> 来安装 ProjectConfig 插件了. 安装完成后, 我们可以通过执行 <code>:ProjectConfig</code> 来检查插件是否成功安装.</p><p>和 <code>:PlugInstall</code> 类似, 我们可以使用 <code>PlugUpdate</code> 来更新插件.</p><h2 id="通过按键来安装或更新插件"><a href="#通过按键来安装或更新插件" class="headerlink" title="通过按键来安装或更新插件"></a>通过按键来安装或更新插件</h2><p>通过命令安装或者更新插件显得很繁琐, 我们期望通过快捷键可以实现下面的效果:</p><ul><li>当光标所在行是以 <code>Plug</code> 开始时, 我们可以直接按快捷键来安装或更新这个 <code>Plug</code> 命令加载的插件;</li><li>当光标所在行不是以 <code>Plug</code> 开始时, 按相同的按键, 我们会安装所有当前未安装的插件, 或者更新所有插件;</li></ul><p>可以通过下面的代码实现我们想要的效果:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">GetPlugNameFronCurrentLine</span><span class="params">(cmd)</span></span></span><br><span class="line">    <span class="keyword">let</span> plugin_name = <span class="built_in">getline</span>(<span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> plugin_name !~ <span class="string">"^Plug"</span></span><br><span class="line">        <span class="keyword">execute</span>(<span class="variable">a:cmd</span> . <span class="string">'!'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> plugin_name = <span class="keyword">split</span>(<span class="keyword">split</span>(plugin_name, <span class="string">"'"</span>)[<span class="number">1</span>], <span class="string">'/'</span>)[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> plugin_name = <span class="keyword">substitute</span>(plugin_name, <span class="string">'\.git$'</span>, <span class="string">''</span>, <span class="string">'g'</span>)</span><br><span class="line"><span class="keyword">execute</span>(<span class="variable">a:cmd</span> .<span class="string">' '</span>. plugin_name)</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nmap</span> ,pi :<span class="keyword">w</span><span class="symbol">&lt;cr&gt;</span>:<span class="keyword">call</span> GetPlugNameFronCurrentLine(<span class="string">'PlugInstall'</span>)<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> ,<span class="keyword">pu</span> :<span class="keyword">call</span> GetPlugNameFronCurrentLine(<span class="string">'PlugUpdate'</span>)<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>当我们按 <code>,pi</code> 时便可安装光标所在行的插件, 或者是按 <code>,pu</code> 来更新光标所在行的插件.</p><h1 id="按需加载插件"><a href="#按需加载插件" class="headerlink" title="按需加载插件"></a>按需加载插件</h1><p>为了提高 vim 的启动速度, 我们期望某些插件只有在特定的情况下才被加载. 例如我们希望 <code>vim-go</code> 插件只有在编辑 go 类型的文件时才会被打开, 便可以通过如下方法实现:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/fatih/vim-go.git'</span>, &#123;<span class="string">'for'</span>: <span class="string">'go'</span>&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>for</code> 后面的文件类型也可以使用列表, 如 <code>{&#39;for&#39;: [&#39;go&#39;, &#39;golang&#39;]}</code> .</p><p>同时, 也可以在调用命令的时候加载插件, 如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/Yggdroot/indentLine'</span>, &#123;<span class="string">'on'</span> : <span class="string">'IndentLinesToggle'</span>&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是只有 <code>IndentLinesToggle</code> 被调用时, 对应的插件才会被加载. <code>on</code> 后面也可以使用列表.</p><h2 id="手动加载插件"><a href="#手动加载插件" class="headerlink" title="手动加载插件"></a>手动加载插件</h2><p>有时我们需要手动加载一些在 vim 启动时未被加载的插件, 例如我们可能希望在没打开 go 类型文件的情况下查看 vim-go 的帮助文档, 这时我们可以通过如下的自定义命令来加载 vim-go :</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">plug_loaded</span><span class="params">(spec)</span></span></span><br><span class="line">  <span class="keyword">let</span> rtp = <span class="keyword">join</span>(<span class="built_in">filter</span>([<span class="variable">a:spec</span>.dir, <span class="built_in">get</span>(<span class="variable">a:spec</span>, <span class="string">'rtp'</span>, <span class="string">''</span>)], <span class="string">'len(v:val)'</span>), <span class="string">'/'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">stridx</span>(&amp;rtp, rtp) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">isdirectory</span>(rtp)</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">plug_names</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sort</span>(<span class="built_in">filter</span>(<span class="built_in">keys</span>(<span class="built_in">filter</span>(<span class="keyword">copy</span>(<span class="variable">g:plugs</span>), &#123; <span class="keyword">k</span>, v -&gt; !<span class="variable">s:plug_loaded</span>(v) &#125;)), <span class="string">'stridx(v:val, a:1) != -1'</span>))</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">command! -nargs=+ -bar -<span class="built_in">complete</span>=customlist,<span class="variable">s:plug_names</span> PlugLoad <span class="keyword">call</span> plug#load([<span class="symbol">&lt;f-args&gt;</span>])</span><br></pre></td></tr></table></figure><p>在 vimrc 中加入上述代码后, 我们便可通过 <code>:PlugLoad vim-go</code> 来加载 vim-go 这个插件. <code>PlugLoad</code> 命令可以自动补全当前未加载的插件.</p><h1 id="Post-update-Hooks"><a href="#Post-update-Hooks" class="headerlink" title="Post-update Hooks"></a>Post-update Hooks</h1><p>我们可以通过 <code>do</code> 标签来指定在安装或者更新完插件后所需要做的操作:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/autozimu/LanguageClient-neovim'</span>, &#123; <span class="string">'do'</span>: <span class="string">':UpdateRemotePlugins'</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="Tip-基于-Ultisnip-快速补全-plug-命令"><a href="#Tip-基于-Ultisnip-快速补全-plug-命令" class="headerlink" title="Tip: 基于 Ultisnip 快速补全 plug 命令"></a>Tip: 基于 Ultisnip 快速补全 plug 命令</h1><p>往往我们在安装插件的时候会先把插件的地址复制到系统剪贴板中, 假定当前系统剪贴板的内容为 <code>https://github.com/hiberabyss/ProjectConfig</code> 借助 Ultisnip 的自动补全功能, 我们可以实现如下的效果:</p><p><img src="/img/vim/vim-plug.gif" alt="complete"></p><p>在 <code>vim.snippets</code> 中添加如下代码即可实现上面的效果:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">snippet plug <span class="string">"add new plugin"</span> <span class="keyword">b</span></span><br><span class="line">Plug <span class="string">'`!v @*`'</span>$<span class="number">1</span></span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为 VIM 的重度患者, 一款好用的插件管理工具显得尤为重要, 毕竟给 VIM 增加新功能, 或者是新增编程语言的支持都需要安装插件. 我个人目前安装了 133 款 VIM 插件.&lt;/p&gt;&lt;p&gt;我使用的 VIM 插件管理工具也从早起的 Vundle 到 NeoBundle, 再到现在使用的 &lt;a href=&quot;https://github.com/junegunn/vim-plug&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vim-plug&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;选择 vim-plug , 是因为它:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;简洁且快速, 没有外部依赖, 整个插件只有一个文件;&lt;/li&gt;&lt;li&gt;该有的功能都有:&lt;ul&gt;&lt;li&gt;按需加载插件(On-demand loading); 这样可以加快 VIM 启动时间&lt;/li&gt;&lt;li&gt;Post-update hooks; 可以在插件安装或者更新时执行一些操作, 如 make 等&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;还提供了更高阶的功能, 使得安装或更新插件都更快速:&lt;ul&gt;&lt;li&gt;并行化地安装或者更新插件;&lt;/li&gt;&lt;li&gt;按照 shallow 的方式 clone 插件库, 下载更迅速&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文是 vim-plug 的一个简明教程, 会介绍它的安装使用, 以及我个人用到的一些 tips.&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>网络并发编程模型</title>
    <link href="https://hiberabyss.github.io/2018/03/20/concurrency-models/"/>
    <id>https://hiberabyss.github.io/2018/03/20/concurrency-models/</id>
    <published>2018-03-20T20:39:11.000Z</published>
    <updated>2018-04-02T13:57:20.377Z</updated>
    
    <content type="html"><![CDATA[<p>网络并发编程模型一般包括三种:</p><ul><li>多进程;</li><li>多线程;</li><li>IO 多路复用</li></ul><p>本文会着重介绍 IO 多路复用这种编程模型, 包括对 select、poll、 epoll 的介绍.</p><a id="more"></a><h1 id="多进程和多线程并发编程模型"><a href="#多进程和多线程并发编程模型" class="headerlink" title="多进程和多线程并发编程模型"></a>多进程和多线程并发编程模型</h1><p>多进程和多线程并发编程模型都是通过新建进程或者线程去处理新的网络连接请求. 因为创建新进程的开销比要比线程高很多, 一般会使用多线程来实现并发.</p><p>如果把 golang 的协程看作是用户态线程的话, 我们可以用下面的代码来说明 多进程/多线程 编程模型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">cnt, _ := c.Read(buf)</span><br><span class="line">c.Write(buf[<span class="number">0</span>:cnt])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server, _ := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1208"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Server started ..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, _ := server.Accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> connHandler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是多进程并发编程模型的话, 就会用 fork 创建子进程去处理新的连接.</p><p>因为在系统中创建进程或者线程的数量是受限的, 也导致基于多进程多线程模型的并发数收到了限制.</p><h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><p>在 Linux/Unix 系统中, 对网络进行了抽象, 一个网络连接可以用一个描述符来表示.</p><p>而 IO 多路复用就是通过某种机制, 使得一个进程或线程可以监视多个描述符, 当某个描述符就绪时, 就能通知程序进行相应的读写操作, 也就是接收或者发送网络数据.</p><p>当我们进行一次 IO 访问时, 例如 read , 一般会发生下面两个过程:</p><ol><li>等待数据准备; 数据从网卡等设备拷贝到操作系统内核缓冲区;</li><li>将数据从内核缓冲区拷贝到进程地址空间内存;</li></ol><p>IO 多路复用包括三种: select、poll、epoll, 它们的实现原理都是类似的:</p><ul><li>先设置一些列的描述符;</li><li>select 等函数会不断地轮询所负责的所有描述符, 当某个描述符准备好时就直接返回, 通知用户程序, 否则就阻塞;</li></ul><p>具体如下图所示:</p><p><img src="/img/network/multiplexing_model.png" alt="multiplexing_model" title="opt title"></p><h2 id="select-缺点"><a href="#select-缺点" class="headerlink" title="select 缺点"></a>select 缺点</h2><p><code>select</code> 函数定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很</li><li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li><li>支持的描述符数量受宏变量 <code>FD_SETSIZE</code> 限制, 默认比较小, 32 系统下是 <code>1024</code>, 64 位系统下是 <code>2048</code></li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>poll 本质上和 select 没有区别, 只是描述 fd 集合的方式不同, poll 使用的是 <code>pollfd</code> 而 select 使用的是 <code>fd_set</code> 方式. <code>pollfd</code> 底层是基于链表实现的.</p><p>poll 没有最大并发连接数的限制.</p><h2 id="epoll-优点"><a href="#epoll-优点" class="headerlink" title="epoll 优点"></a>epoll 优点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>没有最大并发连接的限制，能打开的fd上限远大于1024（1G的内存上能监听约10万个端口）</li><li>采用回调的方式, 效率提升. 只有活跃可用的fd才会调用callback函数, 也就是说 epoll 只管 “活跃” 的连接, 而跟连接总数无关.</li><li>利用 mmap 文件映射内存加速与内核空间的消息传递, 避免了每次调用 select 都要进行内核态数据和用户数据的拷贝.</li></ul><p><code>epoll</code> 适用于存在大量 idle -connection 或者 dead-connection 的场景.</p><h2 id="epoll-工作模式"><a href="#epoll-工作模式" class="headerlink" title="epoll 工作模式"></a>epoll 工作模式</h2><p>epoll对文件描述符的操作有两种模式：LT（level trigger，水平触发）和ET（edge trigger，边缘触发）。二者的区别如下：</p><ul><li>水平触发：默认工作模式，即当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。</li><li>边缘触发：当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时通知一次）</li></ul><p>边缘触发（ET模式）在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞socket，以避免由于一个文件描述符的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><p><a href="http://blog.csdn.net/lisonglisonglisong/article/details/51328062" target="_blank" rel="noopener">这里</a> 有更详细的三者间的对比以及原理介绍.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="http://blog.csdn.net/lisonglisonglisong/article/details/51328062" target="_blank" rel="noopener">IO多路复用：select、poll、epoll示例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络并发编程模型一般包括三种:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;多进程;&lt;/li&gt;&lt;li&gt;多线程;&lt;/li&gt;&lt;li&gt;IO 多路复用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文会着重介绍 IO 多路复用这种编程模型, 包括对 select、poll、 epoll 的介绍.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://hiberabyss.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>给 Hexo 博客集成 gitalk 评论系统</title>
    <link href="https://hiberabyss.github.io/2018/03/19/hexo-gitalk-integration/"/>
    <id>https://hiberabyss.github.io/2018/03/19/hexo-gitalk-integration/</id>
    <published>2018-03-19T18:56:12.000Z</published>
    <updated>2018-03-19T08:12:19.994Z</updated>
    
    <content type="html"><![CDATA[<p>之前博客用的是 <a href="https://valine.js.org/#/" target="_blank" rel="noopener">Valine</a>, 选择它的原因是可以匿名评论. Valine 的缺点是没有办法对新的评论发邮件提醒, 虽然官方文档说是可以的, 但一直没能按文档配置成功.</p><p>Gitalk 是一款基于 github issue 的评论系统, 它的缺点是没办法匿名评论, 但鉴于我的博客是技术博客, 大部分读者应该都是有 github 账号的, 这个缺点还是可以忍受的.</p><a id="more"></a><h1 id="如何集成-Gitalk"><a href="#如何集成-Gitalk" class="headerlink" title="如何集成 Gitalk"></a>如何集成 Gitalk</h1><p><a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a> 官网有详细的安装介绍, <a href="https://github.com/tufu9441/maupassant-hexo/blob/master/layout/_partial/comments.pug" target="_blank" rel="noopener">这儿</a> 是 maupassant 主题的一个集成示例.</p><p><a href="https://github.com/hiberabyss/maupassant-hexo/blob/7b9dbaf84c489e92bfed0a3275b5b7264285cfe5/_config.yml#L11" target="_blank" rel="noopener">这儿</a> 是我的 maupassant 主题中 Gitalk 的配置示例.</p><h1 id="使用-md5-解决-label-过长的问题"><a href="#使用-md5-解决-label-过长的问题" class="headerlink" title="使用 md5 解决 label 过长的问题"></a>使用 md5 解决 label 过长的问题</h1><p>Gitalk 中每篇博客都是和一个 issue 对应的, 博客的评论内容就是存储在对应的 issue 中:</p><ul><li>每篇博客都会有一个 id, 这个 id 是以 issue label 的形式存储的</li><li>id 默认是博客的链接地址</li><li>Github 对 label 的长度有限制, 最多只能是 50 个字符</li></ul><p>当博客的标题比较长时, 很容易就会超过 50 个字符的限制, 这时就会出现 “Error: Validation Failed.” 这样的错误.</p><p>为了解决这个问题, 我们可以使用博客链接地址的 md5 值作为博客的 id. 这需要我们修改 gitalk 的集成脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script(type=&apos;text/javascript&apos; src=&apos;//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&apos;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">id: md5(window.location.pathname),</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hiberabyss/maupassant-hexo/blob/master/layout/_partial/comments.pug#L74" target="_blank" rel="noopener">这儿</a> 是完整的示例代码.</p><p>这里我们使用 <code>window.location.pathname</code> 作为计算 md5 的输入, 它不包括链接中的 host 部分, 这样当我们的博客存在不同的镜像时, 可以让不同主机上的相同博客共享同一套评论.</p><h1 id="初始化所有博客的评论系统"><a href="#初始化所有博客的评论系统" class="headerlink" title="初始化所有博客的评论系统"></a>初始化所有博客的评论系统</h1><p><a href="https://draveness.me/git-comments-initialize" target="_blank" rel="noopener">这篇博客</a>详细介绍了如何对之前的博客初始化评论系统, 这里我们只介绍如何通过 sitemap 的方法来进行初始化.</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>在开始之前需要我们准备好一下环境:</p><ul><li>生成了博客的 sitemap.xml 文件</li><li>在 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Tokens</a> 界面中创建一个新的 token, 需要选中所有 repo 的权限</li><li>安装依赖的 gem 包: <code>sudo gem install faraday activesupport sitemap-parser</code></li></ul><p>上面的环境准备好了之后, 把对应的信息填到下面的 ruby 脚本并执行即可:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">"hiberabyss"</span> <span class="comment"># GitHub 用户名</span></span><br><span class="line">token = <span class="string">"your-token"</span>  <span class="comment"># GitHub Token</span></span><br><span class="line">repo_name = <span class="string">"BlogComments"</span> <span class="comment"># 存放 issues</span></span><br><span class="line">sitemap_url = <span class="string">"https://hiberabyss.github.io/sitemap.xml"</span> <span class="comment"># sitemap</span></span><br><span class="line">kind = <span class="string">"Gitalk"</span> <span class="comment"># "Gitalk" or "gitment"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'open-uri'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'faraday'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'active_support'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'active_support/core_ext'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'sitemap-parser'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'uri'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'digest/md5'</span></span><br><span class="line"></span><br><span class="line">sitemap = SitemapParser.new sitemap_url</span><br><span class="line">urls = sitemap.to_a</span><br><span class="line"></span><br><span class="line">conn = Faraday.new(<span class="symbol">:url</span> =&gt; <span class="string">"https://api.github.com/repos/<span class="subst">#&#123;username&#125;</span>/<span class="subst">#&#123;repo_name&#125;</span>/issues"</span>) <span class="keyword">do</span> <span class="params">|conn|</span></span><br><span class="line">  conn.basic_auth(username, token)</span><br><span class="line">  conn.adapter  Faraday.default_adapter</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">urls.each_with_index <span class="keyword">do</span> <span class="params">|url, index|</span></span><br><span class="line">  uri = URI::parse(url)</span><br><span class="line">  url_md5 = Digest::MD5.hexdigest(uri.path)</span><br><span class="line"></span><br><span class="line">  title = open(url).read.scan(<span class="regexp">/&lt;title&gt;(.*?)&lt;\/title&gt;/</span>).first.first.force_encoding(<span class="string">'UTF-8'</span>)</span><br><span class="line">  response = conn.post <span class="keyword">do</span> <span class="params">|req|</span></span><br><span class="line">    req.body = &#123; <span class="symbol">body:</span> url, <span class="symbol">labels:</span> [kind, url_md5], <span class="symbol">title:</span> title &#125;.to_json</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  puts response.body</span><br><span class="line">  sleep <span class="number">15</span> <span class="keyword">if</span> index % <span class="number">20</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个脚本中我们也是用博客链接的 md5 值作为 id 的.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://draveness.me/git-comments-initialize" target="_blank" rel="noopener">自动初始化 Gitalk 和 Gitment 评论</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前博客用的是 &lt;a href=&quot;https://valine.js.org/#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Valine&lt;/a&gt;, 选择它的原因是可以匿名评论. Valine 的缺点是没有办法对新的评论发邮件提醒, 虽然官方文档说是可以的, 但一直没能按文档配置成功.&lt;/p&gt;&lt;p&gt;Gitalk 是一款基于 github issue 的评论系统, 它的缺点是没办法匿名评论, 但鉴于我的博客是技术博客, 大部分读者应该都是有 github 账号的, 这个缺点还是可以忍受的.&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://hiberabyss.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hiberabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用 Go 进行 Socket 编程</title>
    <link href="https://hiberabyss.github.io/2018/03/14/unix-socket-programming/"/>
    <id>https://hiberabyss.github.io/2018/03/14/unix-socket-programming/</id>
    <published>2018-03-14T19:09:02.000Z</published>
    <updated>2018-03-14T09:33:55.160Z</updated>
    
    <content type="html"><![CDATA[<p>Socket 是对 TCP/UDP 封装后提供的一层接口, 我们可以利用 Socket 编写服务端和客户端, 然后让客户端和服务端建立 TCP 或 UDP 的连接.</p><a id="more"></a><h1 id="Unix-Socket-编程的函数接口"><a href="#Unix-Socket-编程的函数接口" class="headerlink" title="Unix Socket 编程的函数接口"></a>Unix Socket 编程的函数接口</h1><p>在 Unix/Linux 中的 Socket 编程主要通过调用 <code>listen</code>, <code>accept</code>, <code>write</code> <code>read</code> 等函数来实现的. 具体如下图所示:</p><p><img src="/img/socket/unix_socket.png" alt="UnixSocket" title="opt title"></p><h1 id="Golang-中的-Socket-编程模型"><a href="#Golang-中的-Socket-编程模型" class="headerlink" title="Golang 中的 Socket 编程模型"></a>Golang 中的 Socket 编程模型</h1><p>和 Linux Socket 编程相比, go 的 Socket 编程就简单很多. 服务端直接通过 Listen + Accept 模式即可实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        cnt, err := c.Read(buf)</span><br><span class="line">        c.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1208"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := server.Accept()</span><br><span class="line"><span class="keyword">go</span> connHandler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而客户端直接调用 Dial 即可:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c.Write(...)</span><br><span class="line">c.Read(...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1208"</span>)</span><br><span class="line">connHandler(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们会通过一个示例来介绍如果通过 go 进行 Socket 编程, 具体的代码存放在 <a href="https://github.com/hiberabyss/JustDoIt/tree/master/socket" target="_blank" rel="noopener">Github</a> 上.</p><h1 id="实现一个可以接受不同命令的服务端"><a href="#实现一个可以接受不同命令的服务端" class="headerlink" title="实现一个可以接受不同命令的服务端"></a>实现一个可以接受不同命令的服务端</h1><p>我们实现一个服务端, 它可以接受下面这些命令:</p><ul><li><code>ping</code> 探活的命令, 服务端会返回 “pong”</li><li><code>echo</code> 服务端会返回收到的字符串</li><li><code>quit</code> 服务端收到这个命令后就会关闭连接</li></ul><p>具体的服务端代码如下所示:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cnt, err := c.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || cnt == <span class="number">0</span> &#123;</span><br><span class="line">c.Close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inStr := strings.TrimSpace(<span class="keyword">string</span>(buf[<span class="number">0</span>:cnt]))</span><br><span class="line"></span><br><span class="line">inputs := strings.Split(inStr, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> inputs[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"ping"</span>:</span><br><span class="line">c.Write([]<span class="keyword">byte</span>(<span class="string">"pong\n"</span>))</span><br><span class="line"><span class="keyword">case</span> <span class="string">"echo"</span>:</span><br><span class="line">echoStr := strings.Join(inputs[<span class="number">1</span>:], <span class="string">" "</span>) + <span class="string">"\n"</span></span><br><span class="line">c.Write([]<span class="keyword">byte</span>(echoStr))</span><br><span class="line"><span class="keyword">case</span> <span class="string">"quit"</span>:</span><br><span class="line">c.Close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Unsupported command: %s\n"</span>, inputs[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Connection from %v closed. \n"</span>, c.RemoteAddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1208"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to start server, %s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Server Started ..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := server.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to connect, %s\n"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> connHandler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上面的服务端代码并启动后, 我们用 telnet 测试下服务端是否正常工作, 结果如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521018376491.png" width="570"></p><p>我们分别在 telnet 中依次输入了下面三个命令:</p><ul><li><code>ping</code></li><li><code>echo hello, hbliu</code></li><li><code>quit</code></li></ul><h1 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h1><p>我们可以自己实现一个客户端来和我们的服务端进行通信, 实现类似 telnet 的功能, 代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input, _ := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">input = strings.TrimSpace(input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> input == <span class="string">"quit"</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Write([]<span class="keyword">byte</span>(input))</span><br><span class="line"></span><br><span class="line">cnt, err := c.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to read data, %s\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="keyword">string</span>(buf[<span class="number">0</span>:cnt]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1208"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to connect, %s\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connHandler(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以编译上面的代码, 启动后便可执行服务端支持的命令, 如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521018622634.png" width="570"></p><h1 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h1><p>其中虚线标识被动方状态变化, 红色粗线标识主动方的状态变化:</p><p><img src="/img/socket/tcp_status1.jpg" width="600"></p><p>从服务端客户端角度来观察的状态变化:</p><p><img src="/img/socket/tcp_open_close.jpg" width="600"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://blog.csdn.net/tennysonsky/article/details/45621341" target="_blank" rel="noopener">TCP网络编程中connect()、listen()和accept()三者之间的关系</a></li><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="https://github.com/akrennmair/telnet-chat/blob/master/01_echo/echo.go" target="_blank" rel="noopener">Echo Service</a></li><li><a href="https://tonybai.com/2015/11/17/tcp-programming-in-golang/" target="_blank" rel="noopener">Go语言TCP Socket编程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Socket 是对 TCP/UDP 封装后提供的一层接口, 我们可以利用 Socket 编写服务端和客户端, 然后让客户端和服务端建立 TCP 或 UDP 的连接.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="go" scheme="https://hiberabyss.github.io/tags/go/"/>
    
      <category term="Socket" scheme="https://hiberabyss.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信： 共享内存</title>
    <link href="https://hiberabyss.github.io/2018/03/13/shared-memory/"/>
    <id>https://hiberabyss.github.io/2018/03/13/shared-memory/</id>
    <published>2018-03-13T04:21:02.000Z</published>
    <updated>2018-03-29T01:34:42.076Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 中的进程通信主要包括以下几种方式:</p><ul><li>管道(pipe); 流管道 (s_pipe) 和有名管道 (FIFO)</li><li>信号（signal）</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>套接字（socket)</li></ul><p>本文主要介绍共享内存的使用方式, 其中也会用到信号.</p><a id="more"></a><h1 id="使用-shm-机制"><a href="#使用-shm-机制" class="headerlink" title="使用 shm 机制"></a>使用 shm 机制</h1><p>shm 基于 key 来标识一块共享内存区域, 使用 <code>shmget</code> 来创建或获取一段已经存在的共享内存. 当多个进程通过同一个 key 调用 <code>shmget</code> 时, 它们会把同一块内存区域映射到自己的地址空间中.</p><h2 id="读写者模型"><a href="#读写者模型" class="headerlink" title="读写者模型"></a>读写者模型</h2><p>假定存在一个读者进程和一个写着进程, 它们共用一段共享内存, 按照如下的模式工作:</p><ul><li>写者进程往共享内存中写数据; 写完数据后通知读者进程并进入阻塞状态, 等待读者进程发送信号, 然后接着等待用户的输入;</li><li>读者进程等待写者进程的信号, 收到后会打印共享内存中的字符串到 stdout, 发送信号给写者进程, 然后进入阻塞状态;</li></ul><p>当写者进程检查到用户的输入是 <code>quit</code> 时, 便会先给读者进程发送信号, 然后开始进入退出模式, 开始清理共享内存. 当读者进程检测到共享内存中的字符串为 <code>quit</code> 时便会直接退出.</p><h3 id="如何获取对方的-PID"><a href="#如何获取对方的-PID" class="headerlink" title="如何获取对方的 PID"></a>如何获取对方的 PID</h3><p>为了能够给对方发送信号, 读者写着需要知道对方的 PID , 这个信息也是通过共享内存获取的:</p><ul><li>当任何一个进程先启动时, 便会创建共享内存, 同时把自己的 PID 写到共享内存中, 然后进入阻塞状态.</li><li>当后启动的进程检测到共享内存已经存在时, 便从共享内存里读取到对方的 PID 并保存在自己的内存变量里; 同时在共享内存中保存自己的 PID, 给对方进程发送信号;</li><li>当先启动的进程接收到信号后, 便从共享内存中读取对方的 PID 并保存到自己的内存变量里</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><ul><li>启动 writer</li><li>启动 reader</li><li>在 writer 处输入 <code>hello</code>; reader 处会输出 <code>hello</code></li><li>再 writer 处输入 <code>quit</code>; writer 和 reader 都会退出</li></ul><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520873559834.png" width="570"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>相关的代码在 <a href="https://github.com/hiberabyss/JustDoIt/tree/master/ShareMemory" target="_blank" rel="noopener">Github</a> 上, 下载下来后可直接用 <code>make</code> 生成 writer 和 reader.</p><h1 id="使用-mmap-来实现内存共享"><a href="#使用-mmap-来实现内存共享" class="headerlink" title="使用 mmap 来实现内存共享"></a>使用 mmap 来实现内存共享</h1><p>不同于 shm , mmap 并不是专门为共享内存设计的. 它的主要作用是把文件内容映射到内存地址空间中, 可以像访问内存一样访问文件, 从而避免调用 <code>read</code> <code>write</code> 等高开销的系统调用, 提高文件的访问效率.</p><p>在 mmap 的参数中, 我们可以添加一个 <code>MAP_SHARED</code> 标志, 这样当多个进程 mmap 同一个文件的相同部分内容的时候, 它们使用的是同一块内存区域.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们创建两个读写进程, 读进程每隔 2s 输出共享内存里的内容; 写进程会修改共享内存内容, 最终读进程会打印出修改后的内容. 代码保存在 <a href="https://github.com/hiberabyss/JustDoIt/tree/master/ShareMemory/mmap" target="_blank" rel="noopener">Github</a> 上.</p><p>通过匿名文件映射, 我们也能实现父子进程间的内存共享. <a href="https://github.com/hiberabyss/JustDoIt/blob/master/ShareMemory/mmap/anonymous.c" target="_blank" rel="noopener">这儿</a> 是详细代码实现.</p><h2 id="mmap-的一些-tips"><a href="#mmap-的一些-tips" class="headerlink" title="mmap 的一些 tips"></a>mmap 的一些 tips</h2><p>我们可以通过给 mmap 加上 <code>MAP_PRIVATE</code> 标志来防止程序修改文件的内容.</p><p>在通过 mmap 把文件映射进内存后, 我们能操作的整个内存范围是系统中能容纳这些文件内容的最少的页. 例如我们映射了 2 页文件内容到内存, 则我们最多只能操作 2 页内存; 如果我们映射了 1.5 页文件内容到内存, 我们也是最多能操作 2 页内存.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://blog.csdn.net/gatieme/article/details/51005811" target="_blank" rel="noopener">进程间通信之-共享内存Shared Memory–linux内核剖析</a></li><li><a href="http://blog.csdn.net/maverick1990/article/details/48050975" target="_blank" rel="noopener">Linux进程间内存共享机制mmap详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 中的进程通信主要包括以下几种方式:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;管道(pipe); 流管道 (s_pipe) 和有名管道 (FIFO)&lt;/li&gt;&lt;li&gt;信号（signal）&lt;/li&gt;&lt;li&gt;消息队列&lt;/li&gt;&lt;li&gt;共享内存&lt;/li&gt;&lt;li&gt;信号量&lt;/li&gt;&lt;li&gt;套接字（socket)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文主要介绍共享内存的使用方式, 其中也会用到信号.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="IPC" scheme="https://hiberabyss.github.io/tags/ipc/"/>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 golang 实现 ping 命令</title>
    <link href="https://hiberabyss.github.io/2018/03/12/implement-ping-command-via-golang/"/>
    <id>https://hiberabyss.github.io/2018/03/12/implement-ping-command-via-golang/</id>
    <published>2018-03-12T20:27:35.000Z</published>
    <updated>2018-03-12T10:00:50.746Z</updated>
    
    <content type="html"><![CDATA[<p>ping 是一个经常被用来检查主机间连通性的工具, 它基于 ICMP 协议实现, 基本原理很简单: 本机给远程机器发送 ICMP 报文, 远程主机接收到 ICMP 报文后便会回复一个类似的 ICMP 报文; 当本机接收到回复后变认为远程主机是可连接的, 否则便认为这个主机是不可达的.</p><p>为了了解 golang 的网络编程, 我用 go 实现了一个 ping 命令, 本文会介绍如何实现 ping 命令.</p><a id="more"></a><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/hiberabyss/JustDoIt/tree/master/ping" target="_blank" rel="noopener">这里有完整的示例代码</a>, 可以直接执行实现下面的效果 (<strong>注意需要 sudo 权限</strong>):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ping git:(master) sudo go run goping.go baidu.com</span><br><span class="line">Ping 111.13.101.208 (baidu.com):</span><br><span class="line"></span><br><span class="line">28 bytes from 111.13.101.208: seq=1 time=9ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=2 time=9ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=3 time=10ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=4 time=10ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=5 time=9ms</span><br></pre></td></tr></table></figure><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><h2 id="ICMP-报文"><a href="#ICMP-报文" class="headerlink" title="ICMP 报文"></a>ICMP 报文</h2><p>首先我们需要定义出 ICMP 报文头的结构:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ICMP <span class="keyword">struct</span> &#123;</span><br><span class="line">Type        <span class="keyword">uint8</span></span><br><span class="line">Code        <span class="keyword">uint8</span></span><br><span class="line">CheckSum    <span class="keyword">uint16</span></span><br><span class="line">Identifier  <span class="keyword">uint16</span></span><br><span class="line">SequenceNum <span class="keyword">uint16</span></span><br></pre></td></tr></table></figure><p>其中 <code>Type</code> 表明的是 ICMP 的类型, <code>Code</code> 则用来进一步划分 ICMP 的类型, ping 使用的是 echo 类型的 ICMP, 这两个值需要分别设置为 8 和 0.</p><p><code>CheckSum</code> 是报文头的校验值, 以防止在网络传输过程中的数据错误. 会先把这个字段设置为 0 来计算校验值, 计算完成后再把校验值赋值到这个字段.</p><p>ID 是用来标识一个 ICMP, 可以设置为 0; 而 <code>SequenceNum</code> 则是序列号, 可以在发送 ICMP 报文的时候依次累加.</p><p><a href="http://blog.csdn.net/simplelovecs/article/details/51146960" target="_blank" rel="noopener">这篇文章</a>对 ICMP 的结构有更详细的介绍.</p><p>基于上面的描述, 我们可以实现下面这个基于序列号生成 ICMP 报文头的函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getICMP</span><span class="params">(seq <span class="keyword">uint16</span>)</span> <span class="title">ICMP</span></span> &#123;</span><br><span class="line">icmp := ICMP&#123;</span><br><span class="line">Type:        <span class="number">8</span>,</span><br><span class="line">Code:        <span class="number">0</span>,</span><br><span class="line">CheckSum:    <span class="number">0</span>,</span><br><span class="line">Identifier:  <span class="number">0</span>,</span><br><span class="line">SequenceNum: seq,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line">icmp.CheckSum = CheckSum(buffer.Bytes())</span><br><span class="line">buffer.Reset()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> icmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>CheckSum()</code> 是用来计算校验值的函数. 在网络中传输的数据需要是大端字节序的.</p><h2 id="发送及接收-ICMP-报文"><a href="#发送及接收-ICMP-报文" class="headerlink" title="发送及接收 ICMP 报文"></a>发送及接收 ICMP 报文</h2><p>首先, 我们使用 <code>net.DialIP(&quot;ip4:icmp&quot;, nil, destAddr)</code> 来创建一个 ICMP 报文.</p><p>接着我们使用下面的代码填充 ICMP 报文并发送:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(buffer.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送完之后, 我们使用下面的命令接收请求:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">recv := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">receiveCnt, err := conn.Read(recv)</span><br></pre></td></tr></table></figure><p>同时我们还需要统计发送到接收之间所耗费的时间.</p><p>完整的代码如下所示:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendICMPRequest</span><span class="params">(icmp ICMP, destAddr *net.IPAddr)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">conn, err := net.DialIP(<span class="string">"ip4:icmp"</span>, <span class="literal">nil</span>, destAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to connect to remote host: %s\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(buffer.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tStart := time.Now()</span><br><span class="line"></span><br><span class="line">conn.SetReadDeadline((time.Now().Add(time.Second * <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">recv := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">receiveCnt, err := conn.Read(recv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tEnd := time.Now()</span><br><span class="line">duration := tEnd.Sub(tStart).Nanoseconds() / <span class="number">1e6</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%d bytes from %s: seq=%d time=%dms\n"</span>, receiveCnt, destAddr.String(), icmp.SequenceNum, duration)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ping-命令的完整代码"><a href="#ping-命令的完整代码" class="headerlink" title="ping 命令的完整代码"></a>ping 命令的完整代码</h1><p><a href="https://github.com/hiberabyss/JustDoIt/blob/master/ping/goping.go" target="_blank" rel="noopener">Github 上的文件路径</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ICMP <span class="keyword">struct</span> &#123;</span><br><span class="line">Type        <span class="keyword">uint8</span></span><br><span class="line">Code        <span class="keyword">uint8</span></span><br><span class="line">CheckSum    <span class="keyword">uint16</span></span><br><span class="line">Identifier  <span class="keyword">uint16</span></span><br><span class="line">SequenceNum <span class="keyword">uint16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usage</span><span class="params">()</span></span> &#123;</span><br><span class="line">msg := <span class="string">`</span></span><br><span class="line"><span class="string">Need to run as root!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">goping host</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example: ./goping www.baidu.com`</span></span><br><span class="line"></span><br><span class="line">fmt.Println(msg)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getICMP</span><span class="params">(seq <span class="keyword">uint16</span>)</span> <span class="title">ICMP</span></span> &#123;</span><br><span class="line">icmp := ICMP&#123;</span><br><span class="line">Type:        <span class="number">8</span>,</span><br><span class="line">Code:        <span class="number">0</span>,</span><br><span class="line">CheckSum:    <span class="number">0</span>,</span><br><span class="line">Identifier:  <span class="number">0</span>,</span><br><span class="line">SequenceNum: seq,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line">icmp.CheckSum = CheckSum(buffer.Bytes())</span><br><span class="line">buffer.Reset()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> icmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendICMPRequest</span><span class="params">(icmp ICMP, destAddr *net.IPAddr)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">conn, err := net.DialIP(<span class="string">"ip4:icmp"</span>, <span class="literal">nil</span>, destAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to connect to remote host: %s\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(buffer.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tStart := time.Now()</span><br><span class="line"></span><br><span class="line">conn.SetReadDeadline((time.Now().Add(time.Second * <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">recv := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">receiveCnt, err := conn.Read(recv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tEnd := time.Now()</span><br><span class="line">duration := tEnd.Sub(tStart).Nanoseconds() / <span class="number">1e6</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%d bytes from %s: seq=%d time=%dms\n"</span>, receiveCnt, destAddr.String(), icmp.SequenceNum, duration)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSum</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">uint16</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">sum    <span class="keyword">uint32</span></span><br><span class="line">length <span class="keyword">int</span> = <span class="built_in">len</span>(data)</span><br><span class="line">index  <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> length &gt; <span class="number">1</span> &#123;</span><br><span class="line">sum += <span class="keyword">uint32</span>(data[index])&lt;&lt;<span class="number">8</span> + <span class="keyword">uint32</span>(data[index+<span class="number">1</span>])</span><br><span class="line">index += <span class="number">2</span></span><br><span class="line">length -= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> length &gt; <span class="number">0</span> &#123;</span><br><span class="line">sum += <span class="keyword">uint32</span>(data[index])</span><br><span class="line">&#125;</span><br><span class="line">sum += (sum &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint16</span>(^sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">usage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host := os.Args[<span class="number">1</span>]</span><br><span class="line">raddr, err := net.ResolveIPAddr(<span class="string">"ip"</span>, host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to resolve %s, %s\n"</span>, host, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Ping %s (%s):\n\n"</span>, raddr.String(), host)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err = sendICMPRequest(getICMP(<span class="keyword">uint16</span>(i)), raddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error: %s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://blog.csdn.net/simplelovecs/article/details/51146960" target="_blank" rel="noopener">Golang实现ping</a></li><li><a href="http://blog.csdn.net/wangkai_123456/article/details/67632901&lt;Paste" target="_blank" rel="noopener">使用Golang实现简单Ping过程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ping 是一个经常被用来检查主机间连通性的工具, 它基于 ICMP 协议实现, 基本原理很简单: 本机给远程机器发送 ICMP 报文, 远程主机接收到 ICMP 报文后便会回复一个类似的 ICMP 报文; 当本机接收到回复后变认为远程主机是可连接的, 否则便认为这个主机是不可达的.&lt;/p&gt;&lt;p&gt;为了了解 golang 的网络编程, 我用 go 实现了一个 ping 命令, 本文会介绍如何实现 ping 命令.&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://hiberabyss.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>「tor」基于 Tor Browser 翻墙</title>
    <link href="https://hiberabyss.github.io/2018/03/12/tor-vpn/"/>
    <id>https://hiberabyss.github.io/2018/03/12/tor-vpn/</id>
    <published>2018-03-12T15:43:55.000Z</published>
    <updated>2018-03-12T04:45:06.649Z</updated>
    
    <content type="html"><![CDATA[<p>由于众所周知的原因, 国外的一些网站无法被访问到. 但有时偶尔需要访问下这些网站, 我们便可以通过 Tor Browser 来翻墙.</p><a id="more"></a><h1 id="Tor-Browser-的优缺点"><a href="#Tor-Browser-的优缺点" class="headerlink" title="Tor Browser 的优缺点"></a>Tor Browser 的优缺点</h1><p>优点:</p><ul><li>开箱即用, 不需要复杂的配置;</li><li>稳定且没有流量限制; 不像 Lantern, 有时会很不稳定, 而且每个月还有 500MB 的流量限制;</li></ul><p>缺点:</p><ul><li>速度太慢, 基本也就能刷刷网页了;</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>通过 <a href="https://www.torproject.org/projects/torbrowser.html.en" target="_blank" rel="noopener">Tor Browser官网</a> 下载安装即可 (如无法下载, 可在页面下方评论, 我会提供下载链接).</p><p>安装完成打开后, 我们直接选择 <code>meek-amazon</code> 或 <code>meek-azure</code> 即可, 如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520827025220.png" width="548"></p><p>然后点确定, 最后就会进入下面的页面:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520827101652.png" width="637"></p><p>这个浏览器默认就可以翻墙了, 默认可以访问 Google, FaceBook 等网站.</p><h1 id="让-Chrome-也能用上-Tor-Browser-的代理"><a href="#让-Chrome-也能用上-Tor-Browser-的代理" class="headerlink" title="让 Chrome 也能用上 Tor Browser 的代理"></a>让 Chrome 也能用上 Tor Browser 的代理</h1><p>Tor Browser 会在 9150 端口上开启一个 tor 的代理, 当我们打开 Tor Browser 之后, 配置 Chrome 使用这个代理就可以翻墙了. 下图是基于 SwitchyOmega 配置的代理:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520829500960.png" width="855"></p><h1 id="通过-Tor-Browser-切换-IP"><a href="#通过-Tor-Browser-切换-IP" class="headerlink" title="通过 Tor Browser 切换 IP"></a>通过 Tor Browser 切换 IP</h1><p>有些网站会基于 IP 做一些限制, 我们可以很方便的通过 Tor Browser 来切换对外的 IP. 每次当我们点击 “为此站点使用新 Tor 线路” 的时候就会切换成一个新的 IP 地址:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520829784387.png" width="428"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于众所周知的原因, 国外的一些网站无法被访问到. 但有时偶尔需要访问下这些网站, 我们便可以通过 Tor Browser 来翻墙.&lt;/p&gt;
    
    </summary>
    
      <category term="VPN" scheme="https://hiberabyss.github.io/categories/vpn/"/>
    
    
      <category term="tor" scheme="https://hiberabyss.github.io/tags/tor/"/>
    
      <category term="vpn" scheme="https://hiberabyss.github.io/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>并行编程里的一些基本概念</title>
    <link href="https://hiberabyss.github.io/2018/03/07/parallel-programing-concepts/"/>
    <id>https://hiberabyss.github.io/2018/03/07/parallel-programing-concepts/</id>
    <published>2018-03-07T19:43:36.000Z</published>
    <updated>2018-03-07T07:50:41.878Z</updated>
    
    <content type="html"><![CDATA[<p>本文会简单介绍并行编程里经常会遇到的一些基本概念, 及这些不同概念之间的区别; 包括并发和并行; 进程, 线程及协程.</p><a id="more"></a><h1 id="并发-Concurrent-和并行-Parallel"><a href="#并发-Concurrent-和并行-Parallel" class="headerlink" title="并发 (Concurrent) 和并行 (Parallel)"></a>并发 (Concurrent) 和并行 (Parallel)</h1><p>并发和并行的主要区别是实际执行代码的物理部件 (也就是 CPU) 的数量是不一样的.</p><p>并发是指在一个 CPU 上分时执行多个任务. 这样做的好处是:</p><ul><li>能同时执行多个任务; 以前电脑只有一个 CPU 的时候, 就是通过并发来实现同时打开多个程序; 当 CPU 的运算速度足够快时, 用户就感觉好像是这些程序在同时运行;</li><li>当某些任务因为 IO 或网络访问被阻塞时, 可以执行别的计算密集型任务; 这样可以提高程序的执行效率, 提高 CPU 的利用率;</li></ul><p>和并发相对应, 并行就是指多个任务同时跑在不同的 CPU 上; 并行是真正的多任务执行, 在正确地设计及编程下, 能成倍地提高程序的执行效率.</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程和线程都是由操作系统来负责调度的, 操作系统正是通过他们来对任务进行抽象, 并调度到 CPU 上执行的.</p><p>线程的出现是因为进程存在以下缺点:</p><ul><li>不同进程的切换开销很高;</li><li>不同进程间的数据共享很困难;</li></ul><p>相比于进程:</p><ul><li>线程切换开销更小; 只需要更改 CPU 寄存器及线程堆栈这些上下文信息, 不需要更改页表等信息;</li><li>同一进程下的不同线程的内存是共享的, 方便了数据的共享; 因为没有切换内存页表信息, 所有的线程看到的内存都是一样的;</li></ul><p>不同于进程之间的资源是隔离的, 一个进程的崩溃不会影响另外一个进程; 线程共享了很多资源, 同一个进程下的某个线程崩溃, 可能会导致这个进程内的其它线程的崩溃.</p><h2 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="headerlink" title="用户级线程和内核级线程"></a>用户级线程和内核级线程</h2><p>基于是在用户程序中还是在内核中实现对线程的支持, 可以把线程分为用户级线程和内核级线程, 这两种线程的主要区别是:</p><ul><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</li><li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</li><li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li><li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</li></ul><p><a href="http://blog.csdn.net/gatieme/article/details/51892437" target="_blank" rel="noopener">这篇文章</a>中会有更详细的介绍.</p><h2 id="Linux-中的轻量级进程-Light-Weight"><a href="#Linux-中的轻量级进程-Light-Weight" class="headerlink" title="Linux 中的轻量级进程 (Light Weight)"></a>Linux 中的轻量级进程 (Light Weight)</h2><p>linux 内核不存在整真正意义上的线程. linux将所有的执行实体都称之为任务 (task), 每一个任务都类似于一个单线程的进程, 具有内存空间、执行实体、文件资源等. 但 Linux 下不同任务之间可以选择公用内存空间, 因而在实际意义上, 共享同一个内存空间的多个任务构成了一个进程, 而这些任务就成为这个任务里面的轻量级进程.</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程其实就是轻量级的用户级线程, 一般直接由编程语言的 runtime 来实现协程的创建、调度等, 内核无法感知协程的存在.</p><p>goroutine 通过 G-P-M 模型提高了协程的并行性, 防止单个协程阻塞时影响整个进程的运行.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://wangdashuaihenshuai.github.io/2015/10/17/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%9B%9E%E8%B0%83/" target="_blank" rel="noopener">编程中的进程、线程、协程、同步、异步、回调</a></li><li><a href="https://studygolang.com/articles/4964" target="_blank" rel="noopener">进程、线程、轻量级进程、协程</a></li><li><a href="http://blog.csdn.net/gatieme/article/details/51892437" target="_blank" rel="noopener">线程的3种实现方式–内核级线程, 用户级线程和混合型线程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会简单介绍并行编程里经常会遇到的一些基本概念, 及这些不同概念之间的区别; 包括并发和并行; 进程, 线程及协程.&lt;/p&gt;
    
    </summary>
    
      <category term="programing" scheme="https://hiberabyss.github.io/categories/programing/"/>
    
    
      <category term="parallel" scheme="https://hiberabyss.github.io/tags/parallel/"/>
    
      <category term="coroutine" scheme="https://hiberabyss.github.io/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>编程语言中的闭包</title>
    <link href="https://hiberabyss.github.io/2018/03/06/programming-closure/"/>
    <id>https://hiberabyss.github.io/2018/03/06/programming-closure/</id>
    <published>2018-03-06T21:11:13.000Z</published>
    <updated>2018-03-06T10:20:20.184Z</updated>
    
    <content type="html"><![CDATA[<p>闭包是现代的高级编程语言的一个重要概念, 本文会以 Golang 为例来介绍什么是闭包.</p><a id="more"></a><h1 id="什么是闭包-Closure"><a href="#什么是闭包-Closure" class="headerlink" title="什么是闭包 (Closure)"></a>什么是闭包 (Closure)</h1><p>在介绍闭包的定义之前, 我们先来看下闭包的示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greeting</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">data := <span class="string">"Hello "</span> + name</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHi := greeting(<span class="string">"hbliu"</span>)</span><br><span class="line">fmt.Println(sayHi())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Hello hbliu</span></span><br></pre></td></tr></table></figure><p>这段代码就实现了闭包的效果: 虽然 <code>greating</code> 函数已经返回了, 但我们还可以访问到其内部的 <code>data</code> 局部变量. 下面是 <a href="https://coolshell.cn/articles/6731.html" target="_blank" rel="noopener">CoolShell</a> 对闭包的定义:</p><ul><li>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</li><li>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配</li><li>当在一个函数内定义另外一个函数就会产生闭包</li></ul><p>在<a href="https://segmentfault.com/a/1190000000652891" target="_blank" rel="noopener">文章</a>中给了另外一个定义: 闭包是指有权访问另一个函数作用域中的变量的函数</p><p>访问函数内局部变量一般都是通过返回使用了函数局部变量的内部函数来实现的. 由此可见, 为了支持闭包, 编程语言需要提供一下两个特性:</p><ul><li>函数是 First Class Value, 即函数可以作为另一个函数的返回值或参数;</li><li>函数可以嵌套定义, 即可以在一个函数内部定义另外一个函数</li></ul><p>闭包和对象都是既有函数也有数据, 可以用一句话来表明他们的区别: <strong>对象是附有行为的数据，而闭包是附有数据的行为</strong></p><h1 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>闭包可以减少全局变量的个数;</li><li>保存闭包外面的变量状态; 下面是一个示例:</li></ol><p>下面的代买要用 goroutine 来打印一个 slice. 使用闭包前:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resutl:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>可以发现结果都是 3 , 这是因为 goroutine 用的都是同一个变量 <code>n</code>.</p><p>我们可以使用闭包来避免这个问题:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package main provides ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">backup := n</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(backup)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://coolshell.cn/articles/6731.html" target="_blank" rel="noopener">理解JAVASCRIPT的闭包</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-closure/#note_1" target="_blank" rel="noopener">闭包的概念、形式与应用</a></li><li><a href="https://pengweifu.github.io/2014/11/22/Js-Closure.html" target="_blank" rel="noopener">函数闭包的优势和特点</a></li><li><a href="https://segmentfault.com/a/1190000000652891" target="_blank" rel="noopener">详解js闭包</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包是现代的高级编程语言的一个重要概念, 本文会以 Golang 为例来介绍什么是闭包.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://hiberabyss.github.io/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>「git」在 merge 的时候忽略特定的文件</title>
    <link href="https://hiberabyss.github.io/2018/03/03/git-ignore-specific-file/"/>
    <id>https://hiberabyss.github.io/2018/03/03/git-ignore-specific-file/</id>
    <published>2018-03-04T03:06:53.000Z</published>
    <updated>2018-03-19T06:41:58.948Z</updated>
    
    <content type="html"><![CDATA[<p>有时当我们 merge 别的分支到当前分支时, 希望当前分支的某个文件能保持不变. 例如在更新 Hexo 主题时保证 <code>_config.yml</code> 文件不变, 以减少合并冲突的产生. 本文会介绍如何通过 gitattributes 来实现这个目标.</p><a id="more"></a><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>首先需要添加一个 merge driver:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.ours.driver <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在项目的根目录下添加一个文件 <code>.gitattributes</code> , 在文件里添加需要被忽略的文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_config.yml merge=ours</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><script src="https://asciinema.org/a/6KLaDnj58eB7CQ6BDWPqY9udv.js" id="asciicast-6KLaDnj58eB7CQ6BDWPqY9udv" async></script><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在 <code>.gitattributes</code> 里可以设置文件的 merge driver, 我们先是添加了一个名叫 <code>ours</code> 的 merge driver, 这个 driver 被设定为 <code>true</code> , 也就是使用这个 merge driver 的文件在 merge 的时候什么都不会做, 也就会保持不变.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://medium.com/@porteneuve/how-to-make-git-preserve-specific-files-while-merging-18c92343826b" target="_blank" rel="noopener">How to make Git preserve specific files while merging</a></li><li><a href="https://git-scm.com/docs/gitattributes#gitattributes-text" target="_blank" rel="noopener">gitattributes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时当我们 merge 别的分支到当前分支时, 希望当前分支的某个文件能保持不变. 例如在更新 Hexo 主题时保证 &lt;code&gt;_config.yml&lt;/code&gt; 文件不变, 以减少合并冲突的产生. 本文会介绍如何通过 gitattributes 来实现这个目标.&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://hiberabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>区块链常见共识算法</title>
    <link href="https://hiberabyss.github.io/2018/03/01/blockchain-consensus/"/>
    <id>https://hiberabyss.github.io/2018/03/01/blockchain-consensus/</id>
    <published>2018-03-01T21:58:34.000Z</published>
    <updated>2018-03-02T08:41:51.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍现有区块链技术里常见的共识算法: PoW, PoS, DPoS 等.</p><a id="more"></a><p>区块链本质上讲是一个去中心化的分布式账本, 会同时存在多个节点往这个账本里写数据. 由于整个系统所有节点都是平等的, 不存在中心节点, 就会存在下面的问题:</p><ul><li>当多个节点同时往区块链中添加数据时, 应该选择那部分数据写入到最终的区块链中</li></ul><p>PoW 等共识算法就是解决这个问题的方案.</p><h1 id="PoW-Proof-of-Work"><a href="#PoW-Proof-of-Work" class="headerlink" title="PoW (Proof of Work)"></a>PoW (Proof of Work)</h1><p>PoW 对节点提交的区块 B 的格式有如下的要求:</p><p>$$ H(B) \le target $$</p><p>其中 H 是某种 hash 算法, target 是一个固定的数. 也就是说整个区块的 hash 值要小于某个给定的数 target. 只有当区块满足这个条件时才是一个合法的区块, 这个区块才能够被别的节点接受. 而当某个节点找到了这样的合法的区块, 也就是挖到了矿, 会获得一定的数字货币奖励. 这也就解决了无中心多节点的结果决策问题: 整个网络采用最早找到合法区块的节点的数据.</p><p>哈希函数产生的 hash 值是随机的, 而且对原始数据一个很小的改动就能使得 hash 值和之前完全不一样. 为了能得到一个合法的区块, 我们可以往区块里添加一个冗余的整数 nonce, 通过不断地尝试不同的 nonce 来找到合法的区块 (例如可以从 1 开始不断地累加尝试).</p><p>target 的值每隔一段时间就会自动调整, 以保证产生区块的时间是基本固定的, 如比特币会保证每十分钟产生一个新的区块. 当 target 的值越小时, 产生区块的难度就越大. 假定 hash 值的最大值是 $ HASH_{max} $ , 则每一次尝试能找到合法区块的概率为 $ \frac{target}{HASH_{max}} $ . 从这个公式可以看出 target 越小, 每次尝试能找到合法区块的概率也越小.</p><p>在比特币中每过 2016 个块 (两周) 便会调整一下 target 的值, 通过下面的公式进行调整:</p><p>$$ target_{new} = \frac{t_{2016}}{2weeks} * target $$</p><p>其中 $t_2016$ 表示生成前面 2016 个块所花费的时间. 当花费的时间越短, 最终的 target 值也就越小. 生成块的难度值也可以通过下面的公式得出:</p><p>$$ difficulty = \frac{target_1}{current_{target}} $$</p><p>其中 $target_1$ 表示的是区块链中第一个块 (创世块) 的 target 值, 也是最大的 target 值. 它的值是 <code>0x00000000ffff0000000000000000000000000000000000000000000000000000</code></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>安全, 完全的去中心化, 主流的数字币都采用了这种方案; 如 BTC，LTC</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>效率低, 平均每秒只能处理 5 到 7 个交易;</li><li>会耗费大量电力;</li></ul><h1 id="PoS-Proof-of-Stake"><a href="#PoS-Proof-of-Stake" class="headerlink" title="PoS (Proof of Stake)"></a>PoS (Proof of Stake)</h1><p>在 PoW 中找到一个合法的区块需要进行大量的计算, 会花费大量的电力和时间. 为了加快生成区块的速度, PoS 中还会综合考虑节点所持有的数字币的份额. PoS 存在很多不同的实现方法, 其中一种混合模式会利用账户余额来调整挖矿难度:</p><p>$$ H(B, t) \le balance * target $$</p><p>其中 balance 表示账户余额, t 是一个时间戳, 一般对 t 会有一个时间范围的限制, 例如一个小时, 也就是一个节点最多只能尝试 7200 次.</p><p>还有另外一种 PoS 算法, 摘抄自<a href="http://blog.csdn.net/lsttoy/article/details/61624287" target="_blank" rel="noopener">这篇文章</a> :</p><blockquote><p>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p></blockquote><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>提高了处理效率; 基于 PoS 的 Ethereum 每秒大概能处理 30 笔交易左右.</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>没有 PoW 安全, 容易遭受各种攻击; <a href="https://daimajia.com/2017/09/14/pow-and-pos" target="_blank" rel="noopener">这篇博客</a> 有详细介绍</li></ul><h1 id="DPoS-Delegated-Proof-of-Stake"><a href="#DPoS-Delegated-Proof-of-Stake" class="headerlink" title="DPoS (Delegated Proof of Stake)"></a>DPoS (Delegated Proof of Stake)</h1><p>DPoS 会通过不同的策略在不同的时间通过投票产生一小群节点, 由这些节点来负责新区块的创建、验证和相互监督. DPoS 和 PoS 的主要区别在于前者会选出若干代理人, 由代理人来完成记账.</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>提高了处理效率; 如基于 DPoS 的 EOS 能达到每秒几十万的交易数量</li><li>能够对网络进行一定的干预, 减少分叉的出现</li></ul><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>牺牲了部分去中心化</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://daimajia.com/2017/09/14/pow-and-pos" target="_blank" rel="noopener">PoW，PoS，DPoS 综述</a></li><li><a href="https://draveness.me/consensus" target="_blank" rel="noopener">分布式一致性与共识算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍现有区块链技术里常见的共识算法: PoW, PoS, DPoS 等.&lt;/p&gt;
    
    </summary>
    
    
      <category term="blockchain" scheme="https://hiberabyss.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>「neovim」基于 neovim 终端集成 gdb</title>
    <link href="https://hiberabyss.github.io/2018/02/28/neovim-gdb-integration/"/>
    <id>https://hiberabyss.github.io/2018/02/28/neovim-gdb-integration/</id>
    <published>2018-02-28T16:17:35.000Z</published>
    <updated>2018-03-07T03:51:15.992Z</updated>
    
    <content type="html"><![CDATA[<p>相比于 IDE, 当使用 VIM 作为编辑器时, 调试会显得很麻烦. 借助于 neovim 的终端, 我们可以在 VIM 中实现类似 IDE 的编辑调试功能: 在 VIM 编辑窗口中按特定的快捷键即可执行特定的调试命令, 同时在 VIM 窗口中也能显示当前的 断电及程序执行的位置.</p><a id="more"></a><h1 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h1><ul><li>Neovim</li><li>gdb (C, C++);</li><li>delve (golang); 可通过 <code>go get -u github.com/derekparker/delve/cmd/dlv</code> 安装</li></ul><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a><a href="https://asciinema.org/a/dT2652AAwegDo0o0gWKsGOo1W" target="_blank" rel="noopener">演示</a></h1><p>安装 VIM 插件 <a href="https://github.com/hiberabyss/NeovimGdb" target="_blank" rel="noopener">NeovimGDB</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">"https://github.com/hiberabyss/NeovimGdb"</span></span><br></pre></td></tr></table></figure><p>然后便可实现如下的效果:</p><script src="https://asciinema.org/a/dT2652AAwegDo0o0gWKsGOo1W.js" id="asciicast-dT2652AAwegDo0o0gWKsGOo1W" async></script><p>其中的主要操作步骤包括:</p><ol><li>执行 GdbLocal 命令进入 GDB 模式;</li><li>按快捷键 <code>;b</code> 设置断点 (再次按这个快捷键可以取消断点)</li><li>按 <code>;r</code> 开始执行程序;</li><li>按 <code>;n</code> 执行到下一行;</li><li>按 <code>;p</code> 打印光标下的变量;</li><li>按 <code>;gk</code> 退出 GDB 模式</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>对于 C, C++ 类型文件, 可以通过 <code>GdbLocal</code> 启动调试窗口 (或通过默认按键映射 <code>,rd</code>);</li><li>对于 go 类型文件, 可以通过 <code>GoDebug</code> 启动调试窗口;</li><li>可以调用命令 <code>GdbDebugStop</code> 来停止调试 (默认按键映射为 <code>;gk</code>);</li></ul><p>我们可以直接在调试窗口中输入调试命令, 也可以通过下列按键映射从代码窗口往调试窗口发送命令:</p><ul><li><code>;r</code> 发送 r</li><li><code>;c</code> 发送 c</li><li><code>;b</code> 发送 b</li><li><code>;n</code> 发送 n</li><li><code>;p</code> 发送 p word_under_cursor</li><li><code>;u</code> 发送 u</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比于 IDE, 当使用 VIM 作为编辑器时, 调试会显得很麻烦. 借助于 neovim 的终端, 我们可以在 VIM 中实现类似 IDE 的编辑调试功能: 在 VIM 编辑窗口中按特定的快捷键即可执行特定的调试命令, 同时在 VIM 窗口中也能显示当前的 断电及程序执行的位置.&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="gdb" scheme="https://hiberabyss.github.io/tags/gdb/"/>
    
      <category term="neovim" scheme="https://hiberabyss.github.io/tags/neovim/"/>
    
  </entry>
  
  <entry>
    <title>「VIM」基于项目的 VIM 配置</title>
    <link href="https://hiberabyss.github.io/2018/02/28/vim-project-configuration/"/>
    <id>https://hiberabyss.github.io/2018/02/28/vim-project-configuration/</id>
    <published>2018-02-28T16:04:17.000Z</published>
    <updated>2018-03-22T03:58:26.755Z</updated>
    
    <content type="html"><![CDATA[<p>有时在特定的项目中我们需要有特定的 VIM 配置, 这些配置和全局配置是不一致的 或者这个配置是只在这个项目中才能生效的, 我们可以借助插件 <a href="https://github.com/hiberabyss/ProjectConfig" target="_blank" rel="noopener">PorjectConfig</a> 来实现 Per Project 的 VIM 配置.</p><a id="more"></a><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><script src="https://asciinema.org/a/xBJ9avbKQDoPiypawPLYUdg5s.js" id="asciicast-xBJ9avbKQDoPiypawPLYUdg5s" async></script><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>利用 vim-plug 安装:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/hiberabyss/ProjectConfig'</span></span><br></pre></td></tr></table></figure><p>我们便可直接调用 VIM 命令 <code>ProjectConfig</code> 来添加当前项目的配置:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1519787607268.png" width="570"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ProjectConfig 插件会基于 <code>.git</code> <code>.hg</code> 等特殊文件夹来识别当前项目的根目录, 再在这些文件夹内 保存 VIM 配置文件 <code>project_config</code> , 当 VIM 启动时如果检查到这个文件的存在, 便会自动加载它.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时在特定的项目中我们需要有特定的 VIM 配置, 这些配置和全局配置是不一致的 或者这个配置是只在这个项目中才能生效的, 我们可以借助插件 &lt;a href=&quot;https://github.com/hiberabyss/ProjectConfig&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PorjectConfig&lt;/a&gt; 来实现 Per Project 的 VIM 配置.&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>「Docker」网络调试的一个小技巧</title>
    <link href="https://hiberabyss.github.io/2018/02/07/docker-network-debug/"/>
    <id>https://hiberabyss.github.io/2018/02/07/docker-network-debug/</id>
    <published>2018-02-07T16:28:28.000Z</published>
    <updated>2018-02-07T03:45:26.732Z</updated>
    
    <content type="html"><![CDATA[<p>有时当容器地网络出现问题时需要我们利用一些命令进行调试, 但容器内部却没有安装这些调试工具; 这时我们可以新建一个容器, 让它和之前的容器共享同一个 Network Namespace , 这样我们便可以在新容器中调试之前容器地网络问题了.</p><a id="more"></a><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>当我们启动 nginx 容器, 想检查容器中的 80 端口是否开启时会发现没有对应地命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker run --name nginx -d nginx</span><br><span class="line">dce80ba20d033e32195afb92ee4c794aa248066c52fb5c78c6bb452927ed57cb</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker exec -it nginx bash</span><br><span class="line">root@dce80ba20d03:/# nc -zv localhost 80</span><br><span class="line">bash: nc: command not found</span><br><span class="line">root@dce80ba20d03:/# wget -q -O- localhost:80</span><br><span class="line">bash: wget: command not found</span><br><span class="line">root@dce80ba20d03:/#</span><br></pre></td></tr></table></figure><p>这时我们可以基于容器 nginx 的 Network Namespace 启动一个新的容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker run --name debug -it -d --net container:nginx busybox</span><br><span class="line">af3abd9b1cb13b106e452cc97387b042f841ae16e5ad3ba1eaeccab98d0f6f96</span><br></pre></td></tr></table></figure><p>这时便可在新建的 debug 容器中调试之前容器的网络了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker exec -it debug sh</span><br><span class="line">/ # nc -zv localhost 80</span><br><span class="line">localhost (127.0.0.1:80) open</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时当容器地网络出现问题时需要我们利用一些命令进行调试, 但容器内部却没有安装这些调试工具; 这时我们可以新建一个容器, 让它和之前的容器共享同一个 Network Namespace , 这样我们便可以在新容器中调试之前容器地网络问题了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://hiberabyss.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>自己动手实现 Docker bridge network</title>
    <link href="https://hiberabyss.github.io/2018/02/02/docker-bridge-network-practice/"/>
    <id>https://hiberabyss.github.io/2018/02/02/docker-bridge-network-practice/</id>
    <published>2018-02-02T21:45:19.000Z</published>
    <updated>2018-02-06T02:35:00.536Z</updated>
    
    <content type="html"><![CDATA[<p>最近详细了解了 Docker 的网桥网络的工作原理, 便想一步一步地实现 Docker 地网桥网络.</p><a id="more"></a><h1 id="Docker-网桥网络工作原理"><a href="#Docker-网桥网络工作原理" class="headerlink" title="Docker 网桥网络工作原理"></a>Docker 网桥网络工作原理</h1><p>Docker 的网络实现主要会用到以下功能:</p><ul><li>Network Namespace: 用于隔离容器和宿主机之间地网络;</li><li>Veth 设备对: 用于连接宿主机和容器, 每个容器都会有一对 Veth 设备, 一个在容器内, 一个在宿主机内;</li><li>网桥: 通过网桥可以很方便地管理宿主机上的多个 veth 设备, 同时实现不同容器之间地互联;</li><li>Iptables/NetFilter: SNAT 以实现容器内对外网的访问; 实现容器地端口映射等;</li><li>路由</li></ul><p>详细原理如下图所示 (转自这篇<a href="https://draveness.me/docker" target="_blank" rel="noopener">博客</a>):</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1517801503362.png" width="473"></p><h1 id="创建-Network-Namespace"><a href="#创建-Network-Namespace" class="headerlink" title="创建 Network Namespace"></a>创建 Network Namespace</h1><p>通过命令 <code>sudo ip netns add ns1</code> 即可创建名为 ns1 的 network namespace, 我们可以通过下面地命令查看当前系统中已有的 network namespace:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo ls -1 /var/run/netns</span><br><span class="line">ns1</span><br></pre></td></tr></table></figure><p>Note: 我们可以通过命令 <code>sudo ip netns del ns1</code> 来删除之前创建地 network namespace.</p><h1 id="创建-veth-设备对"><a href="#创建-veth-设备对" class="headerlink" title="创建 veth 设备对"></a>创建 veth 设备对</h1><p>通过下面的命令创建:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo ip link add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line"></span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ ip addr show | grep veth</span><br><span class="line">311: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">312: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br></pre></td></tr></table></figure><p>我们把 veth1 移动到 ns1 namespace 里: <code>sudo ip link set veth1 netns ns1</code>. 现在我们在宿主机中就看不到 veth1 了:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ ip addr show | grep veth</span><br><span class="line">312: veth0@if311: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br></pre></td></tr></table></figure><p>当我们切换到 ns1 就可以查看到 veth1 了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo ip netns exec ns1 bash</span><br><span class="line"></span><br><span class="line">[root@ip-10-24-254-11 ec2-user]# ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">311: veth1@if312: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 3e:a0:ce:a7:8f:4c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p>Note: 可以通过 <code>sudo ip del link veth0</code> 来删除这个设备对.</p><h1 id="创建网桥并实现-veth1-和宿主机的互联"><a href="#创建网桥并实现-veth1-和宿主机的互联" class="headerlink" title="创建网桥并实现 veth1 和宿主机的互联"></a>创建网桥并实现 veth1 和宿主机的互联</h1><p>我们在系统默认 namespace 创建网桥 <code>br-demo</code>, 并将 veth0 加入到网桥中:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo brctl addbr br-demo</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo brctl addif br-demo veth0</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo brctl show | grep <span class="string">'br-demo'</span></span><br><span class="line">br-demo         8000.0aa51a826228       no              veth0</span><br></pre></td></tr></table></figure><p>我们给网桥添加 ip 地址: <code>sudo ifconfig br-demo 172.8.0.1</code>. 同时启动 veth0 <code>sudo ip link set dev veth0 up</code>. 再登录进 ns1 namespace 给 veth1 设置 ip 地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# ifconfig veth1 172.8.0.8</span><br><span class="line">[root@ip-10-24-254-11 ec2-user]# ifconfig veth1 172.8.0.8</span><br></pre></td></tr></table></figure><p>这时我们便可以 ping 通 br-demo 的地址了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# ping -c 1 172.8.0.1</span><br><span class="line">PING 172.8.0.1 (172.8.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.8.0.1: icmp_seq=1 ttl=255 time=0.044 ms</span><br></pre></td></tr></table></figure><h1 id="给-veth1-添加外网访问"><a href="#给-veth1-添加外网访问" class="headerlink" title="给 veth1 添加外网访问"></a>给 veth1 添加外网访问</h1><p>在宿主机上编辑 iptables , 添加以下规则:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t filter -A FORWARD -i br-demo ! -o br-demo -j ACCEPT</span><br><span class="line">sudo iptables -t filter -A FORWARD -i br-demo -o br-demo -j ACCEPT</span><br><span class="line">sudo iptables -t filter -A FORWARD -o br-demo -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">sudo iptables -t nat -A POSTROUTING -s 172.8.0.0/16 ! -o br-demo -j MASQUERADE</span><br></pre></td></tr></table></figure><p>在 ns1 namespace 里测试是否可以连通外网:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# ping baidu.com -c1</span><br><span class="line">PING baidu.com (111.13.101.208) 56(84) bytes of data.</span><br><span class="line">64 bytes from 111.13.101.208: icmp_seq=1 ttl=39 time=258 ms</span><br></pre></td></tr></table></figure><h1 id="映射-ns1-内部端口到宿主机"><a href="#映射-ns1-内部端口到宿主机" class="headerlink" title="映射 ns1 内部端口到宿主机"></a>映射 ns1 内部端口到宿主机</h1><p>我们现在 ns1 内部通过 python 启动一个简单地 http server:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# python -m SimpleHTTPServer</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 ...</span><br></pre></td></tr></table></figure><p>在宿主机上我们可以通过 veth1 的 ip 地址访问这个服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ curl -I 172.8.0.8:8000</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: SimpleHTTP/0.6 Python/2.7.12</span><br><span class="line">Date: Mon, 05 Feb 2018 05:54:10 GMT</span><br><span class="line">Content-type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 1718</span><br></pre></td></tr></table></figure><h2 id="从别的机器直接访问宿主机映射后的端口"><a href="#从别的机器直接访问宿主机映射后的端口" class="headerlink" title="从别的机器直接访问宿主机映射后的端口"></a>从别的机器直接访问宿主机映射后的端口</h2><p>把下面地规则加入到 iptalbe 里, 我们便可以通过宿主机的 8088 端口访问到这个 service 了:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 8088 -j DNAT --to-destination 172.8.0.8:8000</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t filter -A FORWARD -p tcp -m tcp --dport 8000 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># need to be in another machine</span></span><br><span class="line">centos@ip-10-24-255-93:~ · 09:50 AM Mon Feb 05 ·</span><br><span class="line">!56 $ curl -I 10.24.254.11:8088</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: SimpleHTTP/0.6 Python/2.7.12</span><br><span class="line">Date: Mon, 05 Feb 2018 09:51:40 GMT</span><br><span class="line">Content-type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 1718</span><br></pre></td></tr></table></figure><p>注意这里必须要在别地机器上访问宿主机的 8088 端口!</p><h2 id="直接在宿主机上访问映射后的端口"><a href="#直接在宿主机上访问映射后的端口" class="headerlink" title="直接在宿主机上访问映射后的端口"></a>直接在宿主机上访问映射后的端口</h2><p>添加如下两条 iptables 规则后即可直接在本机地址上访问:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t nat -A OUTPUT -p tcp -m tcp --dport 8088 -j DNAT --to-destination 172.8.0.8:8000</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t nat -A POSTROUTING -p tcp -m tcp --dport 8000 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ curl -I 127.0.0.1:8088</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: SimpleHTTP/0.6 Python/2.7.12</span><br><span class="line">Date: Tue, 06 Feb 2018 02:33:42 GMT</span><br><span class="line">Content-type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 1718</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">Docker 核心技术与实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近详细了解了 Docker 的网桥网络的工作原理, 便想一步一步地实现 Docker 地网桥网络.&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://hiberabyss.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>利用 kops 在 AWS 上创建 K8S 集群</title>
    <link href="https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/"/>
    <id>https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/</id>
    <published>2018-02-02T19:25:55.000Z</published>
    <updated>2018-02-02T07:09:22.024Z</updated>
    
    <content type="html"><![CDATA[<p>本文会介绍 kops 安装及使用, 如何创建 K8S 集群, 以及可能遇到的问题和解决方案.</p><a id="more"></a><h1 id="kops-的安装"><a href="#kops-的安装" class="headerlink" title="kops 的安装"></a>kops 的安装</h1><p><a href="https://github.com/kubernetes/kops" target="_blank" rel="noopener">kops</a> 是一个帮助在 AWS, Google Cloud 等云平台上创建 K8S 集群的工具. 可以通过如下命令安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span class="string">'"'</span> -f 4)/kops-linux-amd64</span><br><span class="line">chmod +x kops-linux-amd64</span><br><span class="line">sudo mv kops-linux-amd64 /usr/<span class="built_in">local</span>/bin/kops</span><br></pre></td></tr></table></figure><h1 id="使用-kops-创建-K8S-集群"><a href="#使用-kops-创建-K8S-集群" class="headerlink" title="使用 kops 创建 K8S 集群"></a>使用 kops 创建 K8S 集群</h1><h2 id="创建-cluster"><a href="#创建-cluster" class="headerlink" title="创建 cluster"></a>创建 cluster</h2><p>执行下面的命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NETWORKING=<span class="string">"flannel"</span></span><br><span class="line"><span class="built_in">export</span> CLUSTER_NAME=your-cluster-name.k8s.local</span><br><span class="line"><span class="built_in">export</span> VPC_ID=vpc-you-vpc-id</span><br><span class="line"></span><br><span class="line"><span class="comment"># need to create corresponding s3 bucket at first </span></span><br><span class="line"><span class="built_in">export</span> KOPS_STATE_STORE=s3://your-s3 bucket</span><br><span class="line"><span class="built_in">export</span> ZONES=<span class="string">"us-east-1c"</span></span><br><span class="line"></span><br><span class="line">kops create cluster --zones=<span class="variable">$ZONES</span> --name=<span class="variable">$CLUSTER_NAME</span> \</span><br><span class="line">                    --vpc=<span class="variable">$&#123;VPC_ID&#125;</span> --networking <span class="variable">$&#123;NETWORKING&#125;</span> \</span><br><span class="line">                    --node-count 1 --node-size t2.medium  --master-count 1 \</span><br><span class="line">                    --api-loadbalancer-type=internal --dns private \</span><br><span class="line">                    --master-size t2.medium --topology private --image ami-your-image-id</span><br></pre></td></tr></table></figure><h2 id="修改-subnets"><a href="#修改-subnets" class="headerlink" title="修改 subnets"></a>修改 subnets</h2><p>当通过上面的命令创建完 cluster 之后, 我们可能希望 kops 自己去创建 subnet , 而是使用我们 提前配置好的 subnet, 我们可以通过 <code>kops edit cluster your-cluster-name.k8s.local</code> 来编辑 subnets 字段:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">subnets:</span></span><br><span class="line"><span class="attr">- id:</span> <span class="string">subnet-your-id</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">us-east-1c</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">Private</span></span><br><span class="line"><span class="attr">  zone:</span> <span class="string">us-east-1c</span></span><br></pre></td></tr></table></figure><h2 id="启动我们创建的-cluster"><a href="#启动我们创建的-cluster" class="headerlink" title="启动我们创建的 cluster"></a>启动我们创建的 cluster</h2><p>我们需要通过 <code>kops update cluster your-cluster-name.k8s.local --yes</code> 来启动刚刚创建的 cluster.</p><p>这个步骤需要下面的 AWS 权限:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AmazonEC2FullAccess</span><br><span class="line">IAMFullAccess</span><br><span class="line">AmazonS3FullAccess</span><br><span class="line">AmazonVPCFullAccess</span><br></pre></td></tr></table></figure><p>我们可以通过有这些权限的账号来执行上面的命令, 或者在拥有这些权限的 EC2 (通过 IAM Role) 上执行.</p><h1 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h1><p>当执行完上面的步骤之后应该就可以成功地在 AWS 上创建一个 K8S 集群. 可以通过以下步骤去检查问题出现在哪里:</p><h2 id="检查-EC2-instances-有没有被成功创建"><a href="#检查-EC2-instances-有没有被成功创建" class="headerlink" title="检查 EC2 instances 有没有被成功创建"></a>检查 EC2 instances 有没有被成功创建</h2><p>如果没有对应的 EC2 被创建, 我们需要去 Auto Scaling Groups 里检查对应 Activity History :</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1517554624176.png" width="518"></p><p>可能的原因有:</p><ol><li>AMI image 需要被 Accepted;</li><li>没有可用的 Volume ;</li></ol><h2 id="EC2-成功创建但没法被-K8S-集群识别"><a href="#EC2-成功创建但没法被-K8S-集群识别" class="headerlink" title="EC2 成功创建但没法被 K8S 集群识别"></a>EC2 成功创建但没法被 K8S 集群识别</h2><p>这种情况一般是启动的 EC2 上的 <code>kubelet</code> 或 <code>kube-apiserver</code> 未被成功启动.</p><h3 id="master-节点未被成功识别"><a href="#master-节点未被成功识别" class="headerlink" title="master 节点未被成功识别"></a>master 节点未被成功识别</h3><p>如果 master 无法被正常识别, 我们可以取检查 Load Balancer (LB) 是不是有 instance 且状态是不是 <code>InService</code>:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1517554976973.png" width="878"></p><p>这个 LB 是通过检查 443 端口(一般是 kube-apiserver) 来判定服务是不是 InService , 如果这儿有问题, 一般是因为 <code>kube-apiserver</code> 未正常启动</p><h3 id="node-节点未被识别"><a href="#node-节点未被识别" class="headerlink" title="node 节点未被识别"></a>node 节点未被识别</h3><p>这种情况一般是 docker service 或者 kubelet 未被成功启动, 需要登录到对应的机器去检查原因. 可能的情况是 node 节点无法访问外网, 导致无法安装 kubelet 的包.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会介绍 kops 安装及使用, 如何创建 K8S 集群, 以及可能遇到的问题和解决方案.&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="kops" scheme="https://hiberabyss.github.io/tags/kops/"/>
    
      <category term="K8S" scheme="https://hiberabyss.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>直接在 vim 里编辑 iptables 规则</title>
    <link href="https://hiberabyss.github.io/2018/02/02/vim-iptables/"/>
    <id>https://hiberabyss.github.io/2018/02/02/vim-iptables/</id>
    <published>2018-02-02T18:53:52.000Z</published>
    <updated>2018-03-22T03:58:21.341Z</updated>
    
    <content type="html"><![CDATA[<p>这几天为了了解 K8S 的工作原理, 需要频繁地更改 iptables , 直接通过 <code>iptables -t nat -A ...</code> 去添加规则, 或者通过 <code>iptables -t nat -D ...</code> 去删除规则显得很繁琐. 其实我们可以利用 vim 的 autocmd 命令来直接编辑 iptables 并保存.</p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们主要是通过 <code>sudo iptables-save</code> 来导出当前的 iptable 规则, 基于现有的规则做了一些修改之后, 可以通过 <code>sudo iptables-restore</code> 来导入我们修改之后的规则. 同时, 基于 vim 的 autocmd, 我们可以在用 <code>:e</code> 重载 buffer 时基于 <code>iptables-save</code> 来读取当前的 iptables 规则, 在用 <code>:w</code> 保存 buffer 时基于 <code>iptables-restore</code> 来将我们的修改保存到 iptable .</p><h1 id="读取当前-iptalbe-规则"><a href="#读取当前-iptalbe-规则" class="headerlink" title="读取当前 iptalbe 规则"></a>读取当前 iptalbe 规则</h1><p>首先, 我们将当前 iptable 规则导出到文件, 并用 vim 打开:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables-save &gt; iptables.txt</span><br><span class="line">vim iptables.txt</span><br></pre></td></tr></table></figure><p>再执行下面的 vim autocmd 命令:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd! bufread <span class="symbol">&lt;buffer&gt;</span> %d | <span class="number">0</span>r !sudo iptables-save</span><br></pre></td></tr></table></figure><p>这样, 当我们执行 <code>:e</code> 时就回自动获取当前系统中的 iptable 规则.</p><p>命令中的 <code>&lt;buffer&gt;</code> 表明这条 autocmd 只在当前 buffer 中生效.</p><h1 id="保存修改后的-iptable-规则"><a href="#保存修改后的-iptable-规则" class="headerlink" title="保存修改后的 iptable 规则"></a>保存修改后的 iptable 规则</h1><p>执行下面的 vim 命令:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd! bufwritepost <span class="symbol">&lt;buffer&gt;</span> %<span class="keyword">w</span> !sudo iptables-restore</span><br></pre></td></tr></table></figure><p>现在当我们在 vim 中执行 <code>:w</code> 来保存内容时, 当前 buffer 里的规则也会自动保存到 iptalbe 里.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天为了了解 K8S 的工作原理, 需要频繁地更改 iptables , 直接通过 &lt;code&gt;iptables -t nat -A ...&lt;/code&gt; 去添加规则, 或者通过 &lt;code&gt;iptables -t nat -D ...&lt;/code&gt; 去删除规则显得很繁琐. 其实我们可以利用 vim 的 autocmd 命令来直接编辑 iptables 并保存.&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
      <category term="iptables" scheme="https://hiberabyss.github.io/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>一些实用的 kubectl 工具</title>
    <link href="https://hiberabyss.github.io/2018/01/18/kubectl-tips/"/>
    <id>https://hiberabyss.github.io/2018/01/18/kubectl-tips/</id>
    <published>2018-01-18T20:01:46.000Z</published>
    <updated>2018-02-02T06:28:14.646Z</updated>
    
    <content type="html"><![CDATA[<p>使用 K8S 的话就需要经常用到 kubectl ，有一些实用的小工具能提高我们使用 kubectl 的效率。 我把这些小工具打包放在了 <a href="https://github.com/hiberabyss/k8s-tools" target="_blank" rel="noopener">github</a> 上。 执行命令 <code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/hiberabyss/k8s-tools/master/install.sh)&quot;</code> 即可成功安装 (可能需要执行 <code>source ~/.bashrc</code> 或 <code>source ~/.zshrc</code>)。下面我会详细介绍这些小工具的用法。</p><a id="more"></a><p>这个 repo 库里除了帮忙安装 <code>kubectl</code> ，还会提供以下几个工具：<code>kexe</code>, <code>kget</code>, <code>kns</code>, <code>kctx</code>。</p><h1 id="kexe"><a href="#kexe" class="headerlink" title="kexe"></a>kexe</h1><p>这个工具可以帮忙快速地进入 pod ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-11-111-111 ~]$ kexe demo-5d8d688c78-qcs7p sh</span><br><span class="line">/ <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using partial match</span></span><br><span class="line">➜  .dotfiles git:(master) kexe dns-806549836-krtrf sh -n kube-system</span><br><span class="line">Defaulting container name to kubedns.</span><br><span class="line">Use <span class="string">'kubectl describe pod/kube-dns-806549836-krtrf'</span> to see all of the containers <span class="keyword">in</span> this pod.</span><br><span class="line">/ <span class="comment"># %</span></span><br></pre></td></tr></table></figure><p>这个命令接收两个参数 ：</p><ul><li>第一个是 pod 名，可以部分匹配；</li><li>第二个是 shell 的类型，这个参数是可选项，默认是 bash 。</li></ul><p>更详细的是用方法可以执行 <code>kexe -h</code> 获取</p><h1 id="kget"><a href="#kget" class="headerlink" title="kget"></a>kget</h1><p>这个工具是对 <code>kubectl get</code> 的一个封装，但增加了模糊匹配的功能：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ kget pod dns -a</span><br><span class="line">kube-system   dns-controller-5cbcd846f9-dg2kp                         1/1       Running   0          7d        10.24.255.153   ip-10-24-255-153.ec2.internal</span><br><span class="line">kube-system   kube-dns-7f56f9f8c7-7qjg2                               3/3       Running   0          3h        100.96.12.3     ip-10-24-255-251.ec2.internal</span><br><span class="line">kube-system   kube-dns-7f56f9f8c7-l5tvl                               3/3       Running   0          3h        100.96.11.4     ip-10-24-255-117.ec2.internal</span><br><span class="line">kube-system   kube-dns-autoscaler-f4c47db64-895rk                     1/1       Running   0          3h        100.96.12.4     ip-10-24-255-251.ec2.internal</span><br></pre></td></tr></table></figure><p>具体的使用方法可以查看 <code>kget -h</code></p><h1 id="kns"><a href="#kns" class="headerlink" title="kns"></a>kns</h1><p>这个命令可以用来快速地管理 k8s 的 namespaces ，直接执行 <code>kns</code> 可以显示当前所有的 namespaces ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-24-111-153 ~]$ kns</span><br><span class="line">default</span><br><span class="line">kube-public</span><br><span class="line">kube-system</span><br></pre></td></tr></table></figure><p>执行 <code>kns namespace_name</code> 就可以直接切换到对应的 namespace 。</p><h1 id="kctx"><a href="#kctx" class="headerlink" title="kctx"></a>kctx</h1><p>kctx 的用法类似 kns ， 只不过它是用来管理 k8s context ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-11-250-153 ~]$ kctx</span><br><span class="line">bchip2.k8s.local</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 K8S 的话就需要经常用到 kubectl ，有一些实用的小工具能提高我们使用 kubectl 的效率。 我把这些小工具打包放在了 &lt;a href=&quot;https://github.com/hiberabyss/k8s-tools&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt; 上。 执行命令 &lt;code&gt;sh -c &amp;quot;$(wget -O- https://raw.githubusercontent.com/hiberabyss/k8s-tools/master/install.sh)&amp;quot;&lt;/code&gt; 即可成功安装 (可能需要执行 &lt;code&gt;source ~/.bashrc&lt;/code&gt; 或 &lt;code&gt;source ~/.zshrc&lt;/code&gt;)。下面我会详细介绍这些小工具的用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="K8S" scheme="https://hiberabyss.github.io/tags/k8s/"/>
    
      <category term="kubectl" scheme="https://hiberabyss.github.io/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>【AWS】利用 NAT Gateway 给 EC2 增加外网访问</title>
    <link href="https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/"/>
    <id>https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/</id>
    <published>2018-01-18T15:17:48.000Z</published>
    <updated>2018-01-18T03:50:24.660Z</updated>
    
    <content type="html"><![CDATA[<p>默认在 AWS 上让一个 EC2 能访问外网需要它有一个 Public IP ， 但 Public IP 是很有限的资源，我们可以利用 NAT Gateway 来通过一个 Public IP 实现多台 EC2 的外网访问。</p><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>NAT Gateway 会绑定到某个 subnet(属于某个 VPC) 上，这个 subnet 需要是一个 Public Subnet ， 也就是这个 subnet 的 route table 上需要有类似如下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0/0 igw-66666666</span><br></pre></td></tr></table></figure><p>上面的配置表示这个 subnet 的默认流量会通过 Internet Gateway <code>igw-66666666</code> 出去。</p><p>为了实现 Private subnet 里的 EC2 通过 NAT Gateway 访问外网，我们需要有如下的配置：</p><ol><li>一个 Public Subnet：net1；Route Table 上配置了对应的Internet Gateway；</li><li>一个 Private Subnet：net2；net2 需要和 net1 在同一个 VPC 下，如果他们俩没法直接互联，可能是 subnet 上的 ACL 的设置问题；</li><li>一个 NAT Gateway：需要创建在 net1 内。</li></ol><h1 id="创建-NAT-Gateway"><a href="#创建-NAT-Gateway" class="headerlink" title="创建 NAT Gateway"></a>创建 NAT Gateway</h1><p>选择 VPC Dashboard，点击 Create NAT Gateway，再在新的界面里选择一个 Public Subnet 即可：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1516245513504.png" width="536"></p><h1 id="配置-Private-Subnet-的-Route-Table"><a href="#配置-Private-Subnet-的-Route-Table" class="headerlink" title="配置 Private Subnet 的 Route Table"></a>配置 Private Subnet 的 Route Table</h1><p>选中对应的 Private Subnet 界面，在下面的界面中点中 Route Table ，把默认网关改成我们创建的 NAT Gateway 即可。注意这里的 Route Table 不能和 Public Subnet 的 Route Table 一样。</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1516247418560.png" width="607"></p><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>如果配置中间出现问题可以参看 <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html#nat-gateway-troubleshooting" target="_blank" rel="noopener">AWS 官方文档</a> 进行调试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认在 AWS 上让一个 EC2 能访问外网需要它有一个 Public IP ， 但 Public IP 是很有限的资源，我们可以利用 NAT Gateway 来通过一个 Public IP 实现多台 EC2 的外网访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
  </entry>
  
  <entry>
    <title>配置 AWS CLI 工具</title>
    <link href="https://hiberabyss.github.io/2018/01/14/setup-aws-cli/"/>
    <id>https://hiberabyss.github.io/2018/01/14/setup-aws-cli/</id>
    <published>2018-01-15T04:43:04.000Z</published>
    <updated>2018-02-02T07:14:57.493Z</updated>
    
    <content type="html"><![CDATA[<p>通过 aws cli 工具我们可以通过脚本来自动化执行很多操作，同时也能很方便地和 S3 进行交互。 本文会介绍如何安装及配置 aws-cli 工具。</p><a id="more"></a><h1 id="安装-aws-cli"><a href="#安装-aws-cli" class="headerlink" title="安装 aws-cli"></a>安装 aws-cli</h1><p>安装 aws-cli 首先需要安装 python 的 pip 包管理工具，我们可以通过下面的命令安装它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="string">"get-pip.py"</span></span><br><span class="line">sudo python get-pip.py</span><br></pre></td></tr></table></figure><p>成功安装 pip 之后，我们可以很方便地通过 <code>sudo pip install awscli</code> 来安装 aws-cli 工具。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完 aws-cli 之后需要进行配置，主要包括下面三项的配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ aws configure</span><br><span class="line">AWS Access Key ID [****************ZPKQ]:</span><br><span class="line">AWS Secret Access Key [****************vN7P]:</span><br><span class="line">Default region name [None]: us-east-1</span><br></pre></td></tr></table></figure><p>其中 <code>Access Key ID</code> 和 <code>Secret Access Key</code> 可以从 AWS Console 上的 <code>My Security Credentials</code> 页面中获取：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1515945723095.png" width="722"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>当配置新的机器时，可以直接把之前成功配置的机器上的 <code>~/.aws</code> 复制到新机器即可。</p><h1 id="配合-aws-mfa-命令使用"><a href="#配合-aws-mfa-命令使用" class="headerlink" title="配合 aws-mfa 命令使用"></a>配合 aws-mfa 命令使用</h1><p>很多时候为了安全起见，aws 账户会开启 MFA 的认证，这时即使按照上面配置好 aws-cli ， 在执行的时候依然会有访问权限相关的错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ aws s3 ls</span><br><span class="line"></span><br><span class="line">An error occurred (AccessDenied) when calling the ListBuckets operation: Access Denied</span><br></pre></td></tr></table></figure><p>这时我们就需要另外一个工具：aws-mfa</p><h2 id="安装-aws-mfa"><a href="#安装-aws-mfa" class="headerlink" title="安装 aws-mfa"></a>安装 aws-mfa</h2><p>安装 aws-mfa 需要 <code>gem</code> 命令，如果不存在这个命令，可以通过 <code>sudo yum install -y gem</code> 来安装。</p><p>确保 gem 成功安装后，我们便可通过 <code>gem install aws-mfa</code> 来安装 aws-mfa 。</p><h2 id="使用-aws-mfa"><a href="#使用-aws-mfa" class="headerlink" title="使用 aws-mfa"></a>使用 aws-mfa</h2><p>它有两种使用方式：</p><ol><li>直接在 shell 里执行 <code>eval $(aws-mfa)</code>，输入对应的 MFA code:</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="built_in">eval</span> $(aws-mfa)</span><br><span class="line">Enter the 6-digit code from your MFA device:</span><br><span class="line">051059</span><br></pre></td></tr></table></figure><p>执行完这个命令后，我们便可在这个 shell 里正常执行 aws 命令了。</p><ol><li>我们还可以直接在 aws 命令前加上 aws-mfa 。我个人更喜欢这种方式，可以在 shell rc 文件里配置 <code>alias aws=&#39;aws-mfa aws&#39;</code> 这样的 alias</li></ol><h2 id="使用-python-包-awsmfa"><a href="#使用-python-包-awsmfa" class="headerlink" title="使用 python 包 awsmfa"></a>使用 python 包 awsmfa</h2><p>我们还可以使用另一个用 python 写的 aws mfa 的包，使用 <code>pip install awsmfa</code> 安装。 然后执行 <code>awsmfa -i default</code> 即可。 <a href="https://pypi.python.org/pypi/awsmfa" target="_blank" rel="noopener">这里</a> 是详细的使用文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过 aws cli 工具我们可以通过脚本来自动化执行很多操作，同时也能很方便地和 S3 进行交互。 本文会介绍如何安装及配置 aws-cli 工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="MFA" scheme="https://hiberabyss.github.io/tags/mfa/"/>
    
  </entry>
  
  <entry>
    <title>在 Kubernetes 的多个 Nodes 上执行命令</title>
    <link href="https://hiberabyss.github.io/2017/12/01/k8s-run-commands-on-multiple-nodes/"/>
    <id>https://hiberabyss.github.io/2017/12/01/k8s-run-commands-on-multiple-nodes/</id>
    <published>2017-12-01T16:31:04.000Z</published>
    <updated>2018-01-18T03:47:12.467Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们会需要在多个 K8S 的 Nodes 节点上执行一些命令，可以借助工具 <a href="https://github.com/coreos/fabric-kubernetes-nodes" target="_blank" rel="noopener">fabric-kubernetes-nodes</a> 来实现这个目的。</p><a id="more"></a><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>fabric-kubernetes-nodes 主要是利用 fabric 工具以及 K8S 的标签系统来实现的。 我们可以通过给想要进行操作的所有节点加上 label，然后通过这个 label 来对他们进行操作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">label</span> <span class="string">node</span> <span class="string">node1</span> <span class="string">node2</span> <span class="string">my-special-label=true</span></span><br><span class="line"><span class="string">fab</span> <span class="bullet">-u</span> <span class="string">core</span> <span class="bullet">-R</span> <span class="string">my-special-label=true</span> <span class="bullet">--</span> <span class="string">date</span></span><br></pre></td></tr></table></figure><p>对于通过 kops 建立的 K8S 集群，我们可以通过下面的命令来对所有的 Node 节点来进行操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> FAB_KUBE_NODE_ADDRESS_TYPE=InternalIP</span><br><span class="line"></span><br><span class="line">fab -P --fabfile <span class="variable">$HOME</span>/github/fabric-kubernetes-nodes/fabfile.py \</span><br><span class="line">    -R <span class="string">"kubernetes.io/role=node"</span> -- <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>把上面的内容保存为 <code>pnodes</code> 并加上可执行权限，便可很方便地在所有节点上执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➜  blog git:(hexo) ✗ pnodes date</span><br><span class="line">[10.28.12.43] Executing task <span class="string">'&lt;remainder&gt;'</span></span><br><span class="line">[10.28.2.248] Executing task <span class="string">'&lt;remainder&gt;'</span></span><br><span class="line">[10.28.8.119] Executing task <span class="string">'&lt;remainder&gt;'</span></span><br><span class="line">[10.28.8.119] run: date</span><br><span class="line">[10.28.2.248] run: date</span><br><span class="line">[10.28.12.43] run: date</span><br><span class="line">[10.28.12.43] out: Fri Dec 22 02:53:01 UTC 2017</span><br><span class="line">[10.28.12.43] out:</span><br><span class="line"></span><br><span class="line">[10.28.8.119] out: Fri Dec 22 02:53:01 UTC 2017</span><br><span class="line">[10.28.8.119] out:</span><br><span class="line"></span><br><span class="line">[10.28.2.248] out: Fri Dec 22 02:53:01 UTC 2017</span><br><span class="line">[10.28.2.248] out:</span><br></pre></td></tr></table></figure><h2 id="给-Instance-Group-IG-加上-nodeLable"><a href="#给-Instance-Group-IG-加上-nodeLable" class="headerlink" title="给 Instance Group(IG) 加上 nodeLable"></a>给 Instance Group(IG) 加上 nodeLable</h2><p>当通过 kops 创建 k8s 集群时，我们可以通过如下的方式给 IG 加上 label ， 就可以通过这个 label 对整个 IG 进行操作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  nodeLabels:</span></span><br><span class="line"><span class="attr">    ads:</span> <span class="string">perf</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们会需要在多个 K8S 的 Nodes 节点上执行一些命令，可以借助工具 &lt;a href=&quot;https://github.com/coreos/fabric-kubernetes-nodes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fabric-kubernetes-nodes&lt;/a&gt; 来实现这个目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://hiberabyss.github.io/tags/kubernetes/"/>
    
      <category term="Fabric" scheme="https://hiberabyss.github.io/tags/fabric/"/>
    
  </entry>
  
  <entry>
    <title>「VIM」 从远程机器复制文件内容到本机剪贴板</title>
    <link href="https://hiberabyss.github.io/2017/11/30/vim-remote-copy/"/>
    <id>https://hiberabyss.github.io/2017/11/30/vim-remote-copy/</id>
    <published>2017-11-30T17:35:19.000Z</published>
    <updated>2018-03-22T03:58:32.005Z</updated>
    
    <content type="html"><![CDATA[<p>通过 ssh 登录到远程机器后，想要复制远程机器的文件内容是一件很麻烦的事情。 通过拖动来复制对于多行的内容很难实现精确定位，还有可能会遇到换行符的问题。利用 <a href="https://github.com/wincent/clipper" target="_blank" rel="noopener">clipper</a> 命令可以很方便地复制远程机器的内容到本机剪贴板中。</p><a id="more"></a><h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>macOS 系统可以通过 <code>brew install clipper</code> 安装。安装完成后通过 <code>brew services start clipper</code> 启动。 通过以下命令检查 clipper 是不是正常启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ ps -ef | grep clipper</span><br><span class="line">  502   463     1   0  3:07PM ??         0:00.09 /usr/local/opt/clipper/bin/clipper</span><br></pre></td></tr></table></figure><h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><p>当确认 clipper 启动成功后，通过下面的命令连接到远程机器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 8377:localhost:8377 192.168.0.32</span><br></pre></td></tr></table></figure><p>确认远程机器上安装有 <code>nc</code> （对于 CentOS 机器可以通过 <code>sudo yum install -y nmap-ncat</code> 来安装）， 执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello,world | nc localhost 8377</span><br></pre></td></tr></table></figure><p>现在 “hello,world” 字符转已经成功复制到本机的剪贴板了。可以切换到浏览器地址栏粘贴查看结果。</p><p>每次连接远程机器都需要加上 <code>-R 8377:localhost:8377</code> 参数显得有些冗余，我们可以通过修改 <code>~/.ssh/config</code> 文件来实现连接远程主机时默认加上这个参数，只需把下面这行添加到文件 <code>~/.ssh/config</code> 里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RemoteForward 8377 localhost:8377</span><br></pre></td></tr></table></figure><h2 id="在远程主机的-VIM-里复制内容"><a href="#在远程主机的-VIM-里复制内容" class="headerlink" title="在远程主机的 VIM 里复制内容"></a>在远程主机的 VIM 里复制内容</h2><p>我们可以利用 <code>:[range]w[rite] [++opt] !{cmd}</code> 来实现文件内容的复制：</p><ul><li>复制当前行：在 VIM 中执行 <code>:.w !nc localhost 8377</code></li><li>复制选中的行：选中要复制的行后，执行 <code>:&#39;&lt;,&#39;&gt;w !nc localhost 8377</code> ( 进入命令行模式后 VIM 会自动帮忙填充 <code>&#39;&lt;,&#39;&gt;</code>)</li><li>复制整个文件：在 VIM 中执行 <code>:%w !nc localhost 8377</code></li><li>复制 VIM 默认 register 的内容：在 VIM 中执行 <code>:call system(&#39;nc localhost 8377&#39;, @&quot;)</code></li></ul><h3 id="通过-VIM-插件-vim-clipper"><a href="#通过-VIM-插件-vim-clipper" class="headerlink" title="通过 VIM 插件 vim-clipper"></a>通过 VIM 插件 vim-clipper</h3><p>安装了 <a href="https://github.com/wincent/vim-clipper" target="_blank" rel="noopener">vim-clipper</a> 插件后：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/wincent/vim-clipper'</span></span><br></pre></td></tr></table></figure><p>可以直接通过命令 <code>:Clip</code> 来复制 VIM 默认 register 的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过 ssh 登录到远程机器后，想要复制远程机器的文件内容是一件很麻烦的事情。 通过拖动来复制对于多行的内容很难实现精确定位，还有可能会遇到换行符的问题。利用 &lt;a href=&quot;https://github.com/wincent/clipper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clipper&lt;/a&gt; 命令可以很方便地复制远程机器的内容到本机剪贴板中。&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>免密码登录 anyconnect</title>
    <link href="https://hiberabyss.github.io/2017/11/27/no-password-anyconnect/"/>
    <id>https://hiberabyss.github.io/2017/11/27/no-password-anyconnect/</id>
    <published>2017-11-27T14:31:02.000Z</published>
    <updated>2017-11-28T14:59:06.352Z</updated>
    
    <content type="html"><![CDATA[<p>公司的 VPN 需要使用 Cisco Anyconnect 作为客户端来连接，这个客户端在每次连接的时候需都要输入 LDAP 密码来登录。可以通过 Anyconnect 提供的命令行工具来实现免密登录。</p><a id="more"></a><h2 id="通过命令行连接-VPN"><a href="#通过命令行连接-VPN" class="headerlink" title="通过命令行连接 VPN"></a>通过命令行连接 VPN</h2><p>执行命令 <code>/opt/cisco/anyconnect/bin/vpn -s</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  bin /opt/cisco/anyconnect/bin/vpn -s</span><br><span class="line">Cisco AnyConnect Secure Mobility Client (version 4.3.01095) .</span><br><span class="line"></span><br><span class="line">Copyright (c) 2004 - 2016 Cisco Systems, Inc.  All Rights Reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; state: Disconnected</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; state: Disconnected</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; notice: Ready to connect.</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; registered with <span class="built_in">local</span> VPN subsystem.</span></span><br><span class="line"><span class="meta">VPN&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>执行 <code>connect your.vpn.url</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">VPN&gt;</span><span class="bash"> connect your.vpn.url</span></span><br></pre></td></tr></table></figure><p>按照提示输入你的用户名和密码即可连接 VPN 。</p><h2 id="利用脚本连接-VPN"><a href="#利用脚本连接-VPN" class="headerlink" title="利用脚本连接 VPN"></a>利用脚本连接 VPN</h2><p>通过上一步我们知道连接 VPN 需要知道三个信息：VPN 地址、用户名和密码。 密码是比较私密的信息，不适合放在脚本文件里，我们可以利用 macOS 里的 Keychain 工具来保存密码。</p><h3 id="创建一个-Keychain-password-条目"><a href="#创建一个-Keychain-password-条目" class="headerlink" title="创建一个 Keychain password 条目"></a>创建一个 Keychain password 条目</h3><p>打开 Keychain Access 工具，创建一个 <code>FW_OLTP</code> 条目：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1511848299645.png" width="708"></p><p>当这个条目创建完成，我们便可以利用下面的命令获取密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security find-generic-password -wl FW_OLTP</span><br></pre></td></tr></table></figure><h3 id="创建连接-VPN-的脚本文件"><a href="#创建连接-VPN-的脚本文件" class="headerlink" title="创建连接 VPN 的脚本文件"></a>创建连接 VPN 的脚本文件</h3><p>下面的 shell 脚本文件会从 Keychain Access 工具里获取 VPN 的密码，然后利用 <code>vpn</code> 命令行工具连接 VPN ，最后打开 Anyconnect 客户端的 UI 界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">KEYCHAIN_LABEL="FW_LDAP"</span><br><span class="line">USERNAME=$(whoami)</span><br><span class="line">PASSWORD=$(security find-generic-password -wl $KEYCHAIN_LABEL)</span><br><span class="line">VPN_URL="your.vpn.url"</span><br><span class="line">VPN_BIN="/opt/cisco/anyconnect/bin/vpn"</span><br><span class="line">ANYCONNECT_PATH="/Applications/Cisco/Cisco AnyConnect Secure Mobility Client.app"</span><br><span class="line"></span><br><span class="line">get_anyclient_ui_pid() &#123;</span><br><span class="line">    local pid=$(ps -ef | grep "$ANYCONNECT_PATH" | grep -v 'grep' | awk '&#123;print $2&#125;')</span><br><span class="line">    echo $pid</span><br><span class="line"></span><br><span class="line">    if [[ -z "$pid" ]]; then</span><br><span class="line">        return 1</span><br><span class="line">    else</span><br><span class="line">        return 0</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_anyconnect_ui() &#123;</span><br><span class="line">    $VPN_BIN disconnect</span><br><span class="line">    local pid=$(get_anyclient_ui_pid)</span><br><span class="line">    # echo "PID: $pid"</span><br><span class="line"></span><br><span class="line">    if [[ -n "$pid" ]]; then</span><br><span class="line">        kill -9 $pid</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open_client_ui() &#123;</span><br><span class="line">    if ! get_anyclient_ui_pid &amp;&gt; /dev/zero; then</span><br><span class="line">        open "$ANYCONNECT_PATH"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect() &#123;</span><br><span class="line">    # sudo /opt/cisco/anyconnect/bin/vpnagentd</span><br><span class="line">    kill_anyconnect_ui</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">VPN_BIN -s &lt;&lt; EOF</span></span><br><span class="line">connect $VPN_URL</span><br><span class="line"><span class="meta">$</span><span class="bash">USERNAME</span></span><br><span class="line"><span class="meta">$</span><span class="bash">PASSWORD</span></span><br><span class="line">y</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    open_client_ui</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    if [[ -z "$USERNAME" || -z "$PASSWORD" || -z "$VPN_URL" ]]; then</span><br><span class="line">        echo "Error: empty user info"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    case "$1" in</span><br><span class="line">        stop|s )</span><br><span class="line">            $VPN_BIN disconnect</span><br><span class="line">            ;;</span><br><span class="line">        * )</span><br><span class="line">            connect</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main "$*"</span><br></pre></td></tr></table></figure><p>把上面的内容保存到 <code>$HOME/bin/anyconnect</code> （这个路径后面的 Alfred Workflow 会用到）文件中。 给文件加上执行权限 <code>chmod +x $HOME/bin/anyconnect</code> ，现在直接执行 <code>$HOME/bin/anyconnect</code> 就可以连上 VPN 了。</p><h2 id="通过-Alfred-Workflow-插件来连接"><a href="#通过-Alfred-Workflow-插件来连接" class="headerlink" title="通过 Alfred Workflow 插件来连接"></a>通过 Alfred Workflow 插件来连接</h2><p>安装这个 <a href="https://github.com/hiberabyss/BlogDATA/raw/master/alfred/NoPasswdAnyconnect.alfredworkflow" target="_blank" rel="noopener">Alfred Workflow</a> 即可直接通过 Alfred 来直接打开或者断开 VPN 连接：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1511848203769.png" width="555"></p><p>没有任何参数时会连接 VPN ，输入参数 <code>s|stop</code> 就会断开 VPN 连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司的 VPN 需要使用 Cisco Anyconnect 作为客户端来连接，这个客户端在每次连接的时候需都要输入 LDAP 密码来登录。可以通过 Anyconnect 提供的命令行工具来实现免密登录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Alfred" scheme="https://hiberabyss.github.io/tags/alfred/"/>
    
      <category term="macOS" scheme="https://hiberabyss.github.io/tags/macos/"/>
    
      <category term="Anyconnect" scheme="https://hiberabyss.github.io/tags/anyconnect/"/>
    
  </entry>
  
  <entry>
    <title>直接在电脑端获取 AWS 的 MFA code</title>
    <link href="https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/"/>
    <id>https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/</id>
    <published>2017-11-24T01:10:35.000Z</published>
    <updated>2017-11-23T13:06:22.444Z</updated>
    
    <content type="html"><![CDATA[<p>当 AWS 开启了 MFA 认证之后，登录时就需要输入应的 MFA code 。 默认我们可以通过手机应用 Google Authenticator 来获取到这个 code ， 登录的过程还需要使用手机是一种很低效的方式，而且有时还会遇到手机不在身边的情况。 本文会介绍两种可以在电脑端获取 MFA code 的方法。</p><a id="more"></a><h2 id="获取-MFA-设备的秘钥"><a href="#获取-MFA-设备的秘钥" class="headerlink" title="获取 MFA 设备的秘钥"></a>获取 MFA 设备的秘钥</h2><p>在实现电脑端获取 MFA code 前，我们需要先获取到 MFA device 的秘钥：</p><ol><li><p>切换到 “My Security Credentials” 面板： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511439986529.png" width="193"></p></li><li><p>搜索你自己的用户名，并点击进入： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511440121929.png" width="565"></p></li><li><p>切换到 “Security Credentials” tab 页，编辑 “Assigned MFA device”（如果之前有 assign 过 MFA 设备需要先 deactive）： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511440283396.png" width="658"></p></li><li><p>一路点 Next ，最后就可以看到 MFA device 的秘钥了： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511440632702.png" width="739"></p></li></ol><h2 id="通过命令行方式获取-MFA-code"><a href="#通过命令行方式获取-MFA-code" class="headerlink" title="通过命令行方式获取 MFA code"></a>通过命令行方式获取 MFA code</h2><p>先安装 <a href="https://github.com/pcarrier/gauth" target="_blank" rel="noopener">gauth</a> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/pcarrier/gauth</span><br></pre></td></tr></table></figure><p>编辑文件 <code>~/.config/gauth.csv</code>，填入上一步获取的秘钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AWS: ABCDEFGHIJKLMNOPQRSTUVWXYZ234567ABCDEFGHIJKLMNOPQRSTUVWXYZ234567</span><br></pre></td></tr></table></figure><p>还需要设置好文件的权限： <code>chmod 600 ~/.config/gauth.csv</code> 。</p><p>执行命令 <code>gauth</code> 即可获取如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gauth</span><br><span class="line">           prev   curr   next</span><br><span class="line">AWS        315306 135387 483601</span><br><span class="line">[=======                      ]</span><br></pre></td></tr></table></figure><p>其中最后一行表示的是剩余时间。</p><h2 id="通过-Alfred-Workflow-来获取-MFA-code"><a href="#通过-Alfred-Workflow-来获取-MFA-code" class="headerlink" title="通过 Alfred Workflow 来获取 MFA code"></a>通过 Alfred Workflow 来获取 MFA code</h2><p>如果安装了 Alfred 并激活了 Powerpack ，可以通过 Alfred Workflow <a href="https://github.com/moul/alfred-workflow-gauth/blob/develop/Google%20Authenticator.alfredworkflow?raw=true" target="_blank" rel="noopener">Google Authenticator</a> 来实现如下图所示的效果：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1511442187231.png" width="558"></p><p>我个人更喜欢这种方式，直接按回车键就可以把 MFA code 复制到系统剪贴板。</p><h3 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h3><ol><li>下载 <a href="https://github.com/moul/alfred-workflow-gauth/blob/develop/Google%20Authenticator.alfredworkflow?raw=true" target="_blank" rel="noopener">Google Authenticator</a> 并导入到 Alfred；</li><li>编辑文件 <code>~/.gauth</code> ，填入之前获取的 MFA 设备的秘钥：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[AWS - lhbf@qq.com]</span><br><span class="line">secret = ABCDEFGHIJKLMNOPQRSTUVWXYZ234567ABCDEFGHIJKLMNOPQRSTUVWXYZ234567</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/pcarrier/gauth" target="_blank" rel="noopener">https://github.com/pcarrier/gauth</a></li><li><a href="https://github.com/moul/alfred-workflow-gauth" target="_blank" rel="noopener">https://github.com/moul/alfred-workflow-gauth</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当 AWS 开启了 MFA 认证之后，登录时就需要输入应的 MFA code 。 默认我们可以通过手机应用 Google Authenticator 来获取到这个 code ， 登录的过程还需要使用手机是一种很低效的方式，而且有时还会遇到手机不在身边的情况。 本文会介绍两种可以在电脑端获取 MFA code 的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="Alfred" scheme="https://hiberabyss.github.io/tags/alfred/"/>
    
      <category term="macOS" scheme="https://hiberabyss.github.io/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</title>
    <link href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/"/>
    <id>https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/</id>
    <published>2017-11-22T15:21:27.000Z</published>
    <updated>2017-11-22T03:08:42.818Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何创建一个 EBS 卷，并把这个 EBS 卷挂载到 kubernetes 集群里的 POD 上。</p><a id="more"></a><h2 id="创建一个-EBS-卷"><a href="#创建一个-EBS-卷" class="headerlink" title="创建一个 EBS 卷"></a>创建一个 EBS 卷</h2><p>用 <code>aws configure</code> 配置好 aws 命令行之后（如果开启了 mfa ，需要先调用下 <code>eval $(aws-mfa)</code>），我们便可以调用下面的命令创建一个 EBS 卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ec2 create-volume --availability-zone us-east-1a --size 20 --volume-type gp2</span><br></pre></td></tr></table></figure><p>上面的命令会得到类似下面的输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"AvailabilityZone"</span>: <span class="string">"us-east-1a"</span>,</span><br><span class="line">    <span class="attr">"Encrypted"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"VolumeType"</span>: <span class="string">"gp2"</span>,</span><br><span class="line">    <span class="attr">"VolumeId"</span>: <span class="string">"vol-123456we7890ilk12"</span>,</span><br><span class="line">    <span class="attr">"State"</span>: <span class="string">"creating"</span>,</span><br><span class="line">    <span class="attr">"Iops"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"SnapshotId"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"CreateTime"</span>: <span class="string">"2017-01-04T03:53:00.298Z"</span>,</span><br><span class="line">    <span class="attr">"Size"</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录下 <code>VolumeId</code> ，会在后面的步骤中用到。</p><h2 id="创建-K8S-中的-Persistent-Volume-PV"><a href="#创建-K8S-中的-Persistent-Volume-PV" class="headerlink" title="创建 K8S 中的 Persistent Volume (PV)"></a>创建 K8S 中的 Persistent Volume (PV)</h2><p>创建文件 <code>aws-pv.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"v1"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">"PersistentVolume"</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"aws-pv"</span> </span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">amazonEBS</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="string">"10Gi"</span> </span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  awsElasticBlockStore:</span> </span><br><span class="line"><span class="attr">    fsType:</span> <span class="string">"ext4"</span> </span><br><span class="line"><span class="attr">    volumeID:</span> <span class="string">"vol-123456we7890ilk12"</span></span><br></pre></td></tr></table></figure><p>利用 kubectl 创建 Persistent Volume ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f aws-pv.yaml</span><br></pre></td></tr></table></figure><p>可用命令 <code>kubectl get pv</code> 来查看创建的 Persistent Volume 的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM               REASON    AGE</span><br><span class="line">aws-pv     10Gi        RWX           Retain          Available                                7s</span><br></pre></td></tr></table></figure><h2 id="创建-Persistent-Volume-Claim"><a href="#创建-Persistent-Volume-Claim" class="headerlink" title="创建 Persistent Volume Claim"></a>创建 Persistent Volume Claim</h2><p>创建 Persistent Volume Claim (PVC) 和之前创建的 PV 进行绑定，K8S 中的 POD 通过 PVC 来使用 PV 。</p><p>创建文件 <code>pvc.yaml</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">aws-pvc</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">amazonEBS</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">10</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>通过 <code>kubectl</code> 创建 PVC ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pvc.yaml</span><br></pre></td></tr></table></figure><p>查看创建的 PVC ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pvc</span><br></pre></td></tr></table></figure><h2 id="在-POD-中使用-PVC"><a href="#在-POD-中使用-PVC" class="headerlink" title="在 POD 中使用 PVC"></a>在 POD 中使用 PVC</h2><p>先创建对应 PVC 的 volume ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">data-repa</span></span><br><span class="line"><span class="attr">  persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">    claimName:</span> <span class="string">aws-pvc</span></span><br></pre></td></tr></table></figure><p>再添加 mount ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">data-repa</span></span><br><span class="line"><span class="attr">  mountPath:</span> <span class="string">/ads/data/pusher</span></span><br></pre></td></tr></table></figure><h2 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h2><p>一个 EBS 最多只能挂在到一台 EC2 上，如果希望多台机器上的 POD 能共享数据， 则需要使用 EFS、NFS 或 GlusterFS。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.bigbinary.com/2017/04/12/using-kubernetes-persistent-volume-for-persistent-data-storage.html" target="_blank" rel="noopener">Using Kubernetes Persistent volume to store persistent data</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍如何创建一个 EBS 卷，并把这个 EBS 卷挂载到 kubernetes 集群里的 POD 上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="Kubernetes" scheme="https://hiberabyss.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>在代码库中集成 1.0.28 版本的 libmemcached</title>
    <link href="https://hiberabyss.github.io/2017/11/20/integrate-latest-libmemcached/"/>
    <id>https://hiberabyss.github.io/2017/11/20/integrate-latest-libmemcached/</id>
    <published>2017-11-20T15:28:57.000Z</published>
    <updated>2017-11-21T02:27:41.713Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，我们的线上 server 发生了一个很诡异的现象：在访问 memcached 的时候， 某些情况下可能会获取到旧的数据，从而导致我们的 server 不能正常地返回 response 。 我们代码库中的 libmemcahed 是一个很低的版本：0.26，我们便想通过升级 libmecached 到最新 <a href="https://launchpad.net/libmemcached/+download" target="_blank" rel="noopener">1.0.28</a> 版本来尝试解决这个问题。</p><a id="more"></a><p>在集成 libmemcachd 之前，我们需要先在本地把它编译出来。因为我们不需要 sasl 的功能， 便在 config 的时候把它禁用掉了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd libmemcached-1.0.18</span><br><span class="line">./configure --disable-sasl</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>有两种方式可以把 libmemcachd 集成进去：</p><h2 id="直接链接静态库的方式集成"><a href="#直接链接静态库的方式集成" class="headerlink" title="直接链接静态库的方式集成"></a>直接链接静态库的方式集成</h2><p>这需要先把头文件添加到系统搜索路径中，同时把之前编译好的 library (libmemcached-1.0.18/libmemcached/.libs/libmemcached.a) 静态库添加到代码库， 并加入到链接库参数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AM_CPPFLAGS += -isystem $(top_srcdir)/3rd/libmemcached</span><br><span class="line"></span><br><span class="line">ads_LDADD += $(root_path)/3rd/3rd/libmemcached.a</span><br></pre></td></tr></table></figure><h2 id="集成-libmemcachd-代码"><a href="#集成-libmemcachd-代码" class="headerlink" title="集成 libmemcachd 代码"></a>集成 libmemcachd 代码</h2><p>集成 libmemcachd 静态库的方式更简单，能够让我们快速地进行一些测试。 更优雅的集成方式还是集成进 libmemcachd 的代码，让它每次和我们的代码一起 build 。</p><p>首先我们需要把 libmemcachd 的代码复制到我们的代买库中，在复制之前需要用 <code>make clean</code> 清理下编译生成的中间文件。 同时，如果是在非 windows 环境下编译，且把 libmemcachd 通过 <code>-isystem</code> 方式加到搜索路径时，我们需要删除掉 poll.h 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp libmemcached-1.0.18/libmemcached 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libhashkit-1.0/ 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libmemcached-1.0/ 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libmemcachedprotocol-0.0/ 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libhashkit 3rd/libmemcached</span><br></pre></td></tr></table></figure><p>为了防止文件名同名，我们需要把 libhashkit 目录下的文件重命名，加上目录名：<code>zmv -W &#39;*.cc&#39; &#39;libhashkit_*.cc&#39;</code>。 在 3rd/libmemcached 中加入 Makefile.am 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">AM_CFLAGS = --std=c99 -D_POSIX_C_SOURCE</span><br><span class="line">LIBMEMCACHED_ROOT = $(top_srcdir)/3rd/libmemcached</span><br><span class="line">AM_CPPFLAGS = -I$(LIBMEMCACHED_ROOT) -I$(LIBMEMCACHED_ROOT)/libmemcached</span><br><span class="line"></span><br><span class="line">LIBMEMCACHED_SOURCES = \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/csl/context.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/csl/parser.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/csl/scanner.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/instance.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/allocators.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/allocators.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/analyze.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/array.c \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/auto.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/backtrace.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/byteorder.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/callback.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/connect.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/delete.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/do.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/dump.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/error.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/exist.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/fetch.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/flag.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/flush.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/behavior.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/flush_buffers.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/get.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/hash.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/hash.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/hosts.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/initialize_query.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/io.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/key.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/memcached.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/encoding_key.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/namespace.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/options.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/parse.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/poll.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/purge.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/quit.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/quit.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/response.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/result.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/server.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/server_list.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/server_list.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/stats.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/storage.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/strerror.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/string.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/touch.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/udp.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/verbosity.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/version.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/virtual_bucket.c \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/sasl.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_aes.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_algorithm.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_behavior.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_crc32.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_digest.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_encrypt.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_fnv_32.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_fnv_64.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_function.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_has.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_hashkit.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_hsieh.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_jenkins.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_ketama.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_md5.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_murmur.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_murmur3.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_murmur3_api.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_nohsieh.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_one_at_a_time.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_rijndael.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_str_algorithm.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_strerror.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_string.cc</span><br><span class="line"></span><br><span class="line">noinst_LIBRARIES = libmemcached.a</span><br><span class="line"></span><br><span class="line">libmemcached_a_SOURCES = $(LIBMEMCACHED_SOURCES)</span><br><span class="line"></span><br><span class="line">CFLAGS += -Wno-pointer-bool-conversion -Wno-self-assign</span><br></pre></td></tr></table></figure><p>同时把 libmemcachd 的 Makefile 加到 configure.ac 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AC_CONFIG_FILES([ 3rd/libmemcached/Makefile ])</span><br></pre></td></tr></table></figure><h2 id="遇到的一些坑"><a href="#遇到的一些坑" class="headerlink" title="遇到的一些坑"></a>遇到的一些坑</h2><h3 id="禁用-sasl-的问题"><a href="#禁用-sasl-的问题" class="headerlink" title="禁用 sasl 的问题"></a>禁用 sasl 的问题</h3><p>最开始编译的时候没有加 <code>--disable-sasl</code>，导致编译的时候一直提示 sasl 相关的库找不到。 加上这个编译参数之后会在文件 <code>libmemcached-1.0.18/libmemcached-1.0/configure.h</code> 里添加下面的宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBMEMCACHED_WITH_SASL_SUPPORT 0</span></span><br></pre></td></tr></table></figure><p>注意一定要复制正确的 configure.h 文件到到代码库中！</p><h3 id="poll-h-的问题"><a href="#poll-h-的问题" class="headerlink" title="poll.h 的问题"></a>poll.h 的问题</h3><p>刚开始一直会提示 ‘POLLIN’ 之类的变量找不到的问题，检查 libmemcachd 里的 poll.h 文件中是有这个变量的定义的。 再仔细看才发现这个文件定义的变量只有在 windows 下才会生效。</p><p>而且因为我们用 <code>-isystem</code> 把 libmemcachd 目录加了进去，导致编译的时候会用 limcached 里的 poll.h 替换了系统中的这个文件， 但 libmemcachd 的 poll.h 文件在 linux 下又是无效的，从而会导致 ‘POLLIN’ 找不到之类的编译错误。我们把 poll.h 这个文件从 libmemcachd 中删除就可以解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间，我们的线上 server 发生了一个很诡异的现象：在访问 memcached 的时候， 某些情况下可能会获取到旧的数据，从而导致我们的 server 不能正常地返回 response 。 我们代码库中的 libmemcahed 是一个很低的版本：0.26，我们便想通过升级 libmecached 到最新 &lt;a href=&quot;https://launchpad.net/libmemcached/+download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1.0.28&lt;/a&gt; 版本来尝试解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="automake" scheme="https://hiberabyss.github.io/tags/automake/"/>
    
  </entry>
  
  <entry>
    <title>【Neovim】基于自定义 keyword 的自动补全</title>
    <link href="https://hiberabyss.github.io/2017/11/16/vim-word-completion/"/>
    <id>https://hiberabyss.github.io/2017/11/16/vim-word-completion/</id>
    <published>2017-11-16T17:56:38.000Z</published>
    <updated>2018-03-22T02:34:47.980Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们会期望能够根据自定义的一些 keyword 来在 VIM 里进行补全。 我们可以通过 neovim 的插件 deoplete 来实现这个目的。</p><a id="more"></a><p>例如我们在 VIM 里写 sql 的时候可能会遇到很长的列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">transaction__request__context__custom_asset_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure><p>我们可以把这些 keyword 保存在一个文件 <code>keyword.txt</code> 里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction__request__context__custom_asset_idvarchar</span><br></pre></td></tr></table></figure><p>上面的第二个字段是为了能在补全窗口里显示这个字段的类型。通过添加 deoplete 的 source 来解析这个 <code>keyword.txt</code> 文件就可以在 vim 里实现自动补全：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1510809654151.png" width="478"></p><h2 id="如何添加-deoplete-的-source"><a href="#如何添加-deoplete-的-source" class="headerlink" title="如何添加 deoplete 的 source"></a>如何添加 deoplete 的 source</h2><p>首先需要安装 <a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">deoplete</a> 插件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/Shougo/deoplete.nvim'</span></span><br></pre></td></tr></table></figure><p>把下面的内容保存到 <code>deoplete.nvim/rplugin/python3/deoplete/source/keyword.py</code>, 并把 <code>keyword.txt</code> 文件保存到相同的目录：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from os.path import getmtime, dirname, realpath</span><br><span class="line">from collections import namedtuple</span><br><span class="line">from .base import Base</span><br><span class="line"></span><br><span class="line">DictCacheItem = namedtuple(<span class="string">'DictCacheItem'</span>, <span class="string">'mtime candidates'</span>)</span><br><span class="line"></span><br><span class="line">class Source(Base):</span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="keyword">vim</span>):</span><br><span class="line">        super().__init__(<span class="keyword">vim</span>)</span><br><span class="line"></span><br><span class="line">        self.name = <span class="string">'lqs'</span></span><br><span class="line">        self.<span class="keyword">mark</span> = <span class="string">'[LQS]'</span></span><br><span class="line">        self.filetypes = [<span class="string">'sql'</span>]</span><br><span class="line"></span><br><span class="line">        self.__cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def on_event(self, context):</span><br><span class="line">        self.__make_cache(context)</span><br><span class="line"></span><br><span class="line">    def gather_candidates(self, context):</span><br><span class="line">        self.__make_cache(context)</span><br><span class="line"></span><br><span class="line">        candidates = []</span><br><span class="line">        <span class="keyword">for</span> filename in [<span class="keyword">x</span> <span class="keyword">for</span> <span class="keyword">x</span> in self.__get_dictionaries(context)</span><br><span class="line">                         <span class="keyword">if</span> <span class="keyword">x</span> in self.__cache]:</span><br><span class="line">            candidates.<span class="keyword">append</span>(self.__cache[filename].candidates)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'sorted_candidates'</span>: candidates&#125;</span><br><span class="line"></span><br><span class="line">    def __make_cache(self, context):</span><br><span class="line">        <span class="keyword">for</span> filename in self.__get_dictionaries(context):</span><br><span class="line">            mtime = getmtime(filename)</span><br><span class="line">            <span class="keyword">if</span> filename in self.__cache <span class="built_in">and</span> self.__cache[</span><br><span class="line">                    filename].mtime == mtime:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            with <span class="keyword">open</span>(filename, <span class="string">'r'</span>, errors=<span class="string">'replace'</span>) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line">                self.__cache[filename] = DictCacheItem(</span><br><span class="line">                        mtime, [&#123;<span class="string">'word'</span>: <span class="keyword">x</span>.<span class="keyword">split</span>(<span class="string">'\t'</span>)[<span class="number">0</span>], <span class="string">'kind'</span>: <span class="keyword">x</span>.<span class="keyword">split</span>(<span class="string">'\t'</span>)[<span class="number">1</span>]&#125;</span><br><span class="line">                            <span class="keyword">for</span> <span class="keyword">x</span> in sorted([<span class="keyword">x</span>.strip() <span class="keyword">for</span> <span class="keyword">x</span> in <span class="keyword">f</span>], key=str.lower)</span><br><span class="line">                                <span class="keyword">if</span> <span class="built_in">len</span>(<span class="keyword">x</span>.<span class="keyword">split</span>(<span class="string">'\t'</span>)) &gt; <span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    def __get_dictionaries(self, context):</span><br><span class="line">        <span class="keyword">return</span> [dirname(realpath(__file__)) + <span class="string">"/keyword.txt"</span>]</span><br></pre></td></tr></table></figure><h2 id="For-FreeWheel-Guys"><a href="#For-FreeWheel-Guys" class="headerlink" title="For FreeWheel Guys"></a>For FreeWheel Guys</h2><p>我已经把 logquery 的关键词补全打包成一个 vim 插件包，放在了 gitlab 上， 在 <code>.vimrc</code> 里加入下面的内容，然后执行 <code>:PlugInstall!</code> 即可安装：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/Shougo/deoplete.nvim'</span>, &#123; <span class="string">'do'</span>: <span class="string">':UpdateRemotePlugins'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">" need to be after deoplete plugin to take effect</span></span><br><span class="line">Plug <span class="string">'git@git.dev.fwmrm.net:vim/deoplete-fwlqs.git'</span></span><br></pre></td></tr></table></figure><p>该插件只有在编辑 sql 类型的文件时才会生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们会期望能够根据自定义的一些 keyword 来在 VIM 里进行补全。 我们可以通过 neovim 的插件 deoplete 来实现这个目的。&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="neovim" scheme="https://hiberabyss.github.io/tags/neovim/"/>
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>【VIM】neovim 下的 neoterm 插件的一些改进</title>
    <link href="https://hiberabyss.github.io/2017/11/15/neovim-neoterm/"/>
    <id>https://hiberabyss.github.io/2017/11/15/neovim-neoterm/</id>
    <published>2017-11-16T04:52:32.000Z</published>
    <updated>2018-03-22T02:33:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>Neovim 原生支持 terminal 功能，在编辑文件的同时可以新开一个 terminal 窗口， 在其中执行命令。例如我可以在写博客的同时开启一个 terminal 窗口，在其中执行 <code>hexo s</code>， 这样就可以实时预览博客：</p><p>NOTE: 最新版本的 Neoterm 插件已经原生支持 <code>Tnext</code> 和 <code>Tprevious</code> 命令。</p><a id="more"></a><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1510762631758.png" width="570"></p><h2 id="Neoterm"><a href="#Neoterm" class="headerlink" title="Neoterm"></a>Neoterm</h2><p><a href="https://github.com/kassio/neoterm" target="_blank" rel="noopener">Neoterm</a> 是 neovim 下的一款 terminal 管理插件， 通过它可以很方便地：</p><ul><li>开启新的 terminal 窗口：<code>Tnew</code></li><li>给 terminal 窗口发送命令：<code>T python</code></li></ul><h2 id="提高-neoterm-的多-terminal-窗口管理能力"><a href="#提高-neoterm-的多-terminal-窗口管理能力" class="headerlink" title="提高 neoterm 的多 terminal 窗口管理能力"></a>提高 neoterm 的多 terminal 窗口管理能力</h2><p>当通过 neoterm 开启多个 terminal 窗口之后，对这些窗口的管理就会变得很困难。 为了能够高效地管理多个 terminal 窗口，需要能在 terminal 窗口里快速地实现下面两个功能：</p><ul><li>快速跳转到上一个或下一个 terminal 窗口；</li><li>快速打开一个显示当前所有 terminal 的 list。</li></ul><h3 id="terminal-窗口之间的快速跳转"><a href="#terminal-窗口之间的快速跳转" class="headerlink" title="terminal 窗口之间的快速跳转"></a>terminal 窗口之间的快速跳转</h3><p>对于这个功能我们可以利用 vim 的 <code>bnext</code> 和 <code>bprevious</code> 来实现，通过他们来遍历到上一个或下一个 terminal 窗口：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">PreviousTerminal</span><span class="params">()</span></span></span><br><span class="line">    :<span class="keyword">bprevious</span></span><br><span class="line">    <span class="keyword">while</span> &amp;buftype != <span class="string">"terminal"</span></span><br><span class="line">        :<span class="keyword">bprevious</span></span><br><span class="line">    <span class="keyword">endw</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">NextTerminal</span><span class="params">()</span></span></span><br><span class="line">    :<span class="keyword">bnext</span></span><br><span class="line">    <span class="keyword">while</span> &amp;buftype != <span class="string">"terminal"</span></span><br><span class="line">        :<span class="keyword">bnext</span></span><br><span class="line">    <span class="keyword">endw</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">tnoremap <span class="symbol">&lt;silent&gt;</span> &lt;A-[&gt; &lt;<span class="keyword">c</span>-\&gt;<span class="symbol">&lt;c-n&gt;</span>:<span class="keyword">call</span> PreviousTerminal()<span class="symbol">&lt;cr&gt;</span></span><br><span class="line">tnoremap <span class="symbol">&lt;silent&gt;</span> &lt;A-]&gt; &lt;<span class="keyword">c</span>-\&gt;<span class="symbol">&lt;c-n&gt;</span>:<span class="keyword">call</span> NextTerminal()<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码里增加了两个 map ：</p><ul><li>跳转到上一个 terminal 窗口：<code>&lt;A-[&gt;</code></li><li>跳转到下一个 terminal 窗口：<code>&lt;A-]&gt;</code></li></ul><p>这样在 terminal 窗口里按对应的按键就可以跳转到上一个或者下一个 terminal 窗口。</p><h3 id="快速打开当前所有-terminal-窗口的-list"><a href="#快速打开当前所有-terminal-窗口的-list" class="headerlink" title="快速打开当前所有 terminal 窗口的 list"></a>快速打开当前所有 terminal 窗口的 list</h3><p>当打开所有 terminal 的窗口之后，我们便可以快速地选择要切换的 terminal 窗口。</p><p>这个功能是通过 vim 的 <a href="https://github.com/Shougo/unite.vim" target="_blank" rel="noopener">Unite</a> 插件来实现的。 在安装完这个插件之后执行命令 <code>Unite buffer:t</code> 即可打开所有 terminal 的 list。 我们添加如下的 map ，即可实现按 <code>&lt;A-o&gt;</code> 来打开这个 list：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tnoremap <span class="symbol">&lt;A-o&gt;</span> &lt;<span class="keyword">c</span>-\&gt;<span class="symbol">&lt;c-n&gt;</span>:Unite -<span class="keyword">no</span>-start-<span class="keyword">insert</span> <span class="keyword">buffer</span>:t<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Neovim 原生支持 terminal 功能，在编辑文件的同时可以新开一个 terminal 窗口， 在其中执行命令。例如我可以在写博客的同时开启一个 terminal 窗口，在其中执行 &lt;code&gt;hexo s&lt;/code&gt;， 这样就可以实时预览博客：&lt;/p&gt;&lt;p&gt;NOTE: 最新版本的 Neoterm 插件已经原生支持 &lt;code&gt;Tnext&lt;/code&gt; 和 &lt;code&gt;Tprevious&lt;/code&gt; 命令。&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="neovim" scheme="https://hiberabyss.github.io/tags/neovim/"/>
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>【Vim】macOS 系统下 Vim 编辑中文 tips</title>
    <link href="https://hiberabyss.github.io/2017/11/14/vim-mac-chinese-input/"/>
    <id>https://hiberabyss.github.io/2017/11/14/vim-mac-chinese-input/</id>
    <published>2017-11-14T05:01:05.000Z</published>
    <updated>2018-03-22T03:58:09.141Z</updated>
    
    <content type="html"><![CDATA[<p>因为 VIM 里存在多个 mode ，使得编辑中文变得很痛苦。在 Insert mode 下需要使用中文输入法， 但当切换回 Normal 模式后又需要使用英文输入法。在 VIM 里切换 mode 是很经常的事儿， 在需要输入中文时，每次的 mode 切换都需要进行输入法的切换，很麻烦。 通过 <a href="https://github.com/ybian/smartim.git" target="_blank" rel="noopener">SmartIM</a> 插件可以很好的解决这个问题。</p><a id="more"></a><h2 id="SmartIM-是怎么解决这个问题的"><a href="#SmartIM-是怎么解决这个问题的" class="headerlink" title="SmartIM 是怎么解决这个问题的"></a>SmartIM 是怎么解决这个问题的</h2><p>SmartIM 会检查 VIM 的 mode，如果是 Normal 模式时会自动切换成英文输入法；同时， 它也会记录下 Insert 模式下的输入法状态，当进入 Insert 模式后悔自动恢复之前的输入法状态。 SmartIM 目前只能在 macOS 系统下工作。</p><h2 id="安装到-VIM"><a href="#安装到-VIM" class="headerlink" title="安装到 VIM"></a>安装到 VIM</h2><p>我使用 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a> 来管理 VIM 插件，在 <code>.vimrc</code> 里加入下面这行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/ybian/smartim.git'</span></span><br></pre></td></tr></table></figure><p>并执行命令 <code>:PlugInstall smartim</code> 即可成功安装。</p><h2 id="按需启动"><a href="#按需启动" class="headerlink" title="按需启动"></a>按需启动</h2><p>SmartIM 和 VIM 插件 <a href="https://github.com/vim-scripts/VisIncr.git" target="_blank" rel="noopener">VisIncr</a> 有冲突， 它们俩同时启动是会导致 VisIncr 的命令执行特别慢。于是我就想只有在需要 SmartIM 的时候才启动它。</p><p>SmartIM 可以通过一个选项关闭，我们就可以默认关闭它，然后自定义命令来启用或禁止它的使用：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:smartim_disable</span> = <span class="number">1</span></span><br><span class="line">command! -nargs=<span class="number">0</span> SmartIM <span class="keyword">let</span> <span class="variable">g:smartim_disable</span> = <span class="number">0</span></span><br><span class="line">command! -nargs=<span class="number">0</span> SmartIMdisable <span class="keyword">let</span> <span class="variable">g:smartim_disable</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在某些项目里，我们可能希望能默认启动 SmartIM ，比如 blog 目录。这时我们可以利用插件 <a href="https://github.com/hiberabyss/ProjectConfig" target="_blank" rel="noopener">ProjectConfig</a> 来执行 per project 的 VIM 配置， 这个插件需要项目文件通过 git 进行管理，它会自动找到项目根目录，在 <code>.git</code> 目录里加入 VIM 配置文件， 当在这个项目的任意目录启动 VIM 时会自动加载之前保存的配置文件。</p><p>为了能在 blog 项目里默认启动 SmartIM，我们只需执行 <code>:ProjectConfig</code> 命令，然后输入下面的内容即可：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartIM</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为 VIM 里存在多个 mode ，使得编辑中文变得很痛苦。在 Insert mode 下需要使用中文输入法， 但当切换回 Normal 模式后又需要使用英文输入法。在 VIM 里切换 mode 是很经常的事儿， 在需要输入中文时，每次的 mode 切换都需要进行输入法的切换，很麻烦。 通过 &lt;a href=&quot;https://github.com/ybian/smartim.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SmartIM&lt;/a&gt; 插件可以很好的解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="macOS" scheme="https://hiberabyss.github.io/tags/macos/"/>
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>【树莓派】利用 ngrok 进行远程访问</title>
    <link href="https://hiberabyss.github.io/2017/11/13/remote-access-raspberry/"/>
    <id>https://hiberabyss.github.io/2017/11/13/remote-access-raspberry/</id>
    <published>2017-11-14T04:23:42.000Z</published>
    <updated>2017-11-13T15:55:58.857Z</updated>
    
    <content type="html"><![CDATA[<p>当在树莓派上开启了 ssh 服务后，我们可以通过局域网 IP 来进行访问。但如果想要通过外网访问树莓派， 就需要有一个公网的 IP 地址。我们可以利用路由器的端口转发功能，把路由器的某个端口映射到树莓派的 22 端口， 这样就可以通过路由器的公网 IP 地址和端口访问树莓派。但路由器的公网 IP 每隔一段时间就会被更新， 这样就需要先查询路由器的公网 IP ，再去访问树莓派，会比较麻烦。而通过 ngrok ，可以一劳永逸地解决外网访问树莓派的问题。</p><a id="more"></a><h2 id="什么是-Ngrok"><a href="#什么是-Ngrok" class="headerlink" title="什么是 Ngrok"></a>什么是 Ngrok</h2><p>简单来说，ngrok 是一个端口转发服务提供商。它在自己的服务器和运行 ngrok 命令的机器之间建立了一条 tunnel。 这条 tunnel 的两端分别是 ngrok 服务器的某个地址和端口，以及执行 ngrok 命令的机器的地址和端口。 在执行完 ngrok 命令之后，我们会收到服务器的域名和端口，这个域名是公网可见的。通过访问这个域名我们就可以访问执行 ngrok 命令的机器。</p><h2 id="怎么用-Ngrok"><a href="#怎么用-Ngrok" class="headerlink" title="怎么用 Ngrok"></a>怎么用 Ngrok</h2><p>首先需要下载 <a href="https://ngrok.com/download" target="_blank" rel="noopener">ngrok</a> 的二进制文件， 然后在 ngrok 的<a href="https://ngrok.com/" target="_blank" rel="noopener">官网</a>上进行注册，注册完成后点击 Dashboard 就可以看到你自己的 token，然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok authtoken 5k7rUCwLksfx1qwpT17en_7tMFYmC1u8cHGeppJzic1</span><br></pre></td></tr></table></figure><p>再通过下面的命令映射出树莓派的 22 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok tcp 22</span><br></pre></td></tr></table></figure><p>上面的命令执行完后会有下面这样的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ngrok by @inconshreveable</span><br><span class="line"></span><br><span class="line">Session Status                online</span><br><span class="line">Account                       Hongbo Liu (Plan: Free)</span><br><span class="line">Version                       2.2.8</span><br><span class="line">Region                        United States (us)</span><br><span class="line">Web Interface                 http://127.0.0.1:4040</span><br><span class="line">Forwarding                    tcp://0.tcp.ngrok.io:15393 -&gt; localhost:22</span><br><span class="line"></span><br><span class="line">Connections                   ttl     opn     rt1     rt5     p50     p90</span><br><span class="line">                              2       0       0.00    0.00    35.11   58.65</span><br></pre></td></tr></table></figure><p>我们就可以通过 <code>ssh -p 15393 pi@0.tcp.ngrok.io</code> 来访问到树莓派了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当在树莓派上开启了 ssh 服务后，我们可以通过局域网 IP 来进行访问。但如果想要通过外网访问树莓派， 就需要有一个公网的 IP 地址。我们可以利用路由器的端口转发功能，把路由器的某个端口映射到树莓派的 22 端口， 这样就可以通过路由器的公网 IP 地址和端口访问树莓派。但路由器的公网 IP 每隔一段时间就会被更新， 这样就需要先查询路由器的公网 IP ，再去访问树莓派，会比较麻烦。而通过 ngrok ，可以一劳永逸地解决外网访问树莓派的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Raspberry" scheme="https://hiberabyss.github.io/tags/raspberry/"/>
    
  </entry>
  
  <entry>
    <title>Git Tips：修改 commits</title>
    <link href="https://hiberabyss.github.io/2017/03/21/git-amend-commits/"/>
    <id>https://hiberabyss.github.io/2017/03/21/git-amend-commits/</id>
    <published>2017-03-21T04:03:41.000Z</published>
    <updated>2018-03-19T06:41:35.331Z</updated>
    
    <content type="html"><![CDATA[<p>总是会存在这样的场景：在开开心心地用 git commit 提交了代码之后，才发现 commit message 里有 typo， 或者是有些文件忘记 commit 了，又或者是有些垃圾文件被不小心 commit 了；这时不要伤心、不要难过， 因为 git 给你提供了后悔药。</p><a id="more"></a><h2 id="修改最近的一个-commit"><a href="#修改最近的一个-commit" class="headerlink" title="修改最近的一个 commit"></a>修改最近的一个 commit</h2><p>如果想要修改最近的一个 commit 的 message，直接执行 <code>git commit --amend</code>，然后在编辑器里修改 message 信息， 保存退出即可。</p><p>如果想把当前未提交的更改添加到最近的一个 commit 里，则直接执行 <code>git commit -a --amend</code> 即可。</p><p>如果要删除最近 commit 里提交的一些内容则可能会稍显麻烦一些，需要先用 <code>git reset HEAD^</code> 来撤销最近的一次 commit， 然后再用 <code>git checkout file</code> 来进行操作。</p><h2 id="修改多个-commits"><a href="#修改多个-commits" class="headerlink" title="修改多个 commits"></a>修改多个 commits</h2><p>在开发的过程中，创建 commit 可能会比较随意，等到实际提交代码时，为了能有一个清晰的 git 提交历史， 我们可能需要重新编辑这些 commits，以使得每个 commit 都是有意义的。为了实现这个目的，我们需要使用到 git rebase。</p><p>进行 rebase 之前需要知道要进行 rebase 的 commits 的 list， 这个 list 是一个半开区间 (commit-before-you-want-to-change, HEAD], 然后通过下面的命令进行 rebase：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i commit-before-you-want-to-change</span><br></pre></td></tr></table></figure><p>修改每个 commit 前的命令即可实现对应的操作，常用的命令有：</p><ul><li>reword: 修改当前 commit 的 message</li><li>squash: 把当前 commit 合并到前一个 commit，包括 commit message</li><li>fixup: 类似 squash，但会丢弃当前 commit 的 message</li><li>edit: 修改当前 commit</li></ul><p>在进行 rebase 时比较麻烦的一点是获取要修改的最后一个 commit 的 hash 值。在多人协作的项目里，我们每次要进行 rebase 的 commit 应该都是由自己提交的， 基于这个假设，可以通过脚本获取最后一个不是当前作者的 commit 作为 git rebase 的参数，对应的 shell 脚本代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">username="`git config user.name`"</span><br><span class="line"></span><br><span class="line">firstOtherCommitIdx() &#123;</span><br><span class="line">idx=0</span><br><span class="line">for (( i = 0; i &lt; 100; i++ )); do</span><br><span class="line">current_user="$(git log --format="%an" -n 1 --skip $i)"</span><br><span class="line">if [[ $current_user != $username ]]; then</span><br><span class="line">idx=$i</span><br><span class="line">break</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">echo $idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">local idx="$(firstOtherCommitIdx)"</span><br><span class="line">if [[ $idx == 0 ]]; then</span><br><span class="line">echo "There is no commit for user: $username"</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">local other_commit="$(git log --format="%H" -n 1 --skip $idx)"</span><br><span class="line">git rebase -i $other_commit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main $*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是会存在这样的场景：在开开心心地用 git commit 提交了代码之后，才发现 commit message 里有 typo， 或者是有些文件忘记 commit 了，又或者是有些垃圾文件被不小心 commit 了；这时不要伤心、不要难过， 因为 git 给你提供了后悔药。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://hiberabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 入门教程</title>
    <link href="https://hiberabyss.github.io/2017/03/13/hexo-tutorial/"/>
    <id>https://hiberabyss.github.io/2017/03/13/hexo-tutorial/</id>
    <published>2017-03-14T01:41:42.000Z</published>
    <updated>2018-04-06T22:18:58.991Z</updated>
    
    <content type="html"><![CDATA[<p>晚上把搭好的博客发给了我的 Best Gay Friend 看，本来只是想赚一下浏览量，但基友说也想搭一个类似的博客系统。 寻思着可以写一篇利用 Github Pages 搭建 Hexo 博客系统的入门教程，既可以增加一篇“凑字数”的博客，又可以急基友之所急。</p><a id="more"></a><h2 id="Hexo-的安装及使用"><a href="#Hexo-的安装及使用" class="headerlink" title="Hexo 的安装及使用"></a>Hexo 的安装及使用</h2><p>Hexo 的安装很简单，只用一条命令即可搞定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装完之后就可以用下面的命令来初始化一个博客：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>然后用 <code>hexo server -o</code> 在本地打开对应的博客网站。 这些在 <a href="https://github.com/hexojs/hexo#quick-start" target="_blank" rel="noopener">Hexo 官网</a>上都有介绍。</p><h2 id="自定义Hexo"><a href="#自定义Hexo" class="headerlink" title="自定义Hexo"></a>自定义Hexo</h2><p>可以通过编辑 <code>blog/_config.yml</code> 文件来对你的博客网站进行配置，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">始于珞尘</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Hongbo</span> <span class="string">Liu</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><p>也可以修改博客的主题：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">maupassant-hexo</span></span><br></pre></td></tr></table></figure><p>主题 <code>maupassant</code> 的具体安装方法可以参考它的 <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="自定义-maupassant-主题"><a href="#自定义-maupassant-主题" class="headerlink" title="自定义 maupassant 主题"></a>自定义 maupassant 主题</h3><ul><li>启用博客阅读数统计：<code>busuanzi: true</code></li><li>启用对应的 Comment 插件：gitalk, gitment、valine</li></ul><h4 id="增加统计功能"><a href="#增加统计功能" class="headerlink" title="增加统计功能"></a>增加统计功能</h4><p>基于这个<a href="https://github.com/aimer1124/blog_theme" target="_blank" rel="noopener">文档</a>添加总阅读数的统计:</p><ul><li><p>在 <code>after_footer.pug</code> 文件中加入以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if theme.busuanzi == true</span><br><span class="line">  script(src=&apos;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&apos;, async)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>footer.pug</code> 文件中加入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if theme.busuanzi == true</span><br><span class="line">  div</span><br><span class="line">    | Total</span><br><span class="line">    span#busuanzi_container_site_pv</span><br><span class="line">      span= &apos; &apos;</span><br><span class="line">      span#busuanzi_value_site_pv</span><br><span class="line">    span(rel=&apos;nofollow&apos;)= &apos; &apos; + __(&apos; hits, &apos;)</span><br><span class="line">    span#busuanzi_container_site_uv</span><br><span class="line">      span#busuanzi_value_site_uv</span><br><span class="line">    span(rel=&apos;nofollow&apos;)= &apos; &apos; + __(&apos; visitors. &apos;)</span><br></pre></td></tr></table></figure></li></ul><p>通过<a href="https://web.umeng.com/main.php?c=site&amp;a=show" target="_blank" rel="noopener">友盟</a>添加站长统计信息. 注册完成后添加你的博客域名, 然后进入获取代码页面, 复制你期望的样式的代码, 去除掉代码中的 script tag, 把代码放到文件 <code>footer.pug</code> 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">  script.</span><br><span class="line">       var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_avoid_use&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s22.cnzz.com/z_stat.php%3Fid%3Dyour-id-number%26online%3D1%26show%3Dline&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));</span><br></pre></td></tr></table></figure><p>设置完成后可以看到类似下图的效果:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1523053025720.png" width="485"></p><p><a href="https://github.com/hiberabyss/maupassant-hexo/blob/master/layout/_partial/footer.pug" target="_blank" rel="noopener">这里</a> 是完整的代码文件.</p><h2 id="部署-Hexo-博客到-Github-Pages"><a href="#部署-Hexo-博客到-Github-Pages" class="headerlink" title="部署 Hexo 博客到 Github Pages"></a>部署 Hexo 博客到 Github Pages</h2><p>要使用 Github Pages 首先需要你建一个名称为 <code>your-github-id.github.io</code> 的 repository，同时需要在 repository 的设置里开启 Github Pages 功能。</p><p>然后在 <code>blog</code> 目录里安装 hexo deploy 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 文件里添加如下的配置：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:your-github-id/your-github-id.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><p>最后执行 <code>hexo generate -d</code>，大功告成！打开 <a href="http://your-github-id.github.io" target="_blank" rel="noopener">http://your-github-id.github.io</a> 就可以访问你的博客网站了！</p><h3 id="使用-443-端口连接"><a href="#使用-443-端口连接" class="headerlink" title="使用 443 端口连接"></a>使用 443 端口连接</h3><p>有时 22 端口可能会被防火墙拦截, 这时执行 <code>hexo deploy</code> 时可能会遇到下面的错误信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/Users/hbliu/Projects/Hexo/blog/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:180:13)</span><br><span class="line">    at maybeClose (internal/child_process.js:936:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:220:5)</span><br></pre></td></tr></table></figure><p>这时我们可以利用 443 端口进行 ssh 连接. 修改 <code>~/.ssh/config</code> 文件, 添加以下内容:</p><ul><li><p>For Github:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    hostname ssh.github.com</span><br><span class="line">    port 443</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li><li><p>For coding.net (<a href="https://coding.net/help/faq/git/git.html#_22_SSH" target="_blank" rel="noopener">git-faq</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host git.coding.net</span><br><span class="line">    hostname git-ssh.coding.net</span><br><span class="line">    port 443</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ul><h3 id="强制开启-https"><a href="#强制开启-https" class="headerlink" title="强制开启 https"></a>强制开启 https</h3><p>我们可以在 Github Pages 库里的设置中开启强制 https 功能, 这样当用户访问 http 的网页时 会自动重定向到 https 页面.</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521450041622.png" width="491"></p><h2 id="搜索引擎检索"><a href="#搜索引擎检索" class="headerlink" title="搜索引擎检索"></a>搜索引擎检索</h2><p>为了让博客的内容能被百度和 Google 检索，首先需要生成对应的 sitemap：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>分别在 <a href="http://zhanzhang.baidu.com/site/index" target="_blank" rel="noopener">百度站长工具</a> 和 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Google 站长工具</a> 里对你的博客站点进行验证。</p><p>选择<code>文件验证</code>的方式进行验证，把下载的文件放在 <code>source</code> 目录下，并对文件内容进行编辑，在文件首部加入如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">sitemap:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>这样就可以防止 Hexo 在生成博客网站时在验证文件里添加额外的内容，导致验证失败。</p><p>也可以在博客的配置文件里加入如下的配置来防止这些文件被渲染：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">baidu_verify*.html</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">google*.html</span></span><br></pre></td></tr></table></figure><p>具体的匹配规则可以参考这个 <a href="https://github.com/hexojs/hexo/issues/1146#issuecomment-88380140" target="_blank" rel="noopener">comment</a></p><p>当博客站点验证成功后便可以选择用 sitemap 的方式自动提交链接。对于百度，在站长平台工具里选择 “网页抓取–&gt;链接提交–&gt;自动提交–&gt;sitemap”， 如下图所示：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1489936271715.png" width="560"></p><p>对于 Google 择选择 “抓取–&gt;站点地图–&gt;添加站点地图”，如下图所示：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1489936644191.png" width="379"></p><p>当做完所有这些操作之后可以通过 <code>site:your-blog-site</code> 这个搜索来验证你的博客有没有被百度和 Google 收录。 一般需要几天的时间才能保证你的博客被搜索引擎检索到。</p><h2 id="利用-Hexo-部署-nodeppt-生成的-slides"><a href="#利用-Hexo-部署-nodeppt-生成的-slides" class="headerlink" title="利用 Hexo 部署 nodeppt 生成的 slides"></a>利用 Hexo 部署 nodeppt 生成的 slides</h2><p>我平时经常会用 nodeppt 来制作 slides, 它也是基于 markdown 文件来生成对应的 slides html 文件. 我们可以把 slides html 文件放在 hexo 中, 这样便可以实现在线的 slides, 方便和别人进行分享.</p><p>我把 slides 的入口地址放在了和 “关于” 平级的 tab 上, 如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521705301743.png" width="455"></p><p>对于基于 maupassant 的主题, 可以在 <code>menu</code> 下面加上 Slides 入口:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">Slides</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">slides/publish</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-slideshare</span></span><br></pre></td></tr></table></figure><p>然后在 <code>source/slides/src</code> 中添加 markdown 源文件, 在目录 <code>sources/slides</code> 中使用 <code>nodeppt generate src -a</code> 生成对应的 html 文件.</p><p>当我们点击 Slides 的 tab 时便可进入如下的界面:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521711265507.png" width="290"></p><h2 id="使用七牛作为图床"><a href="#使用七牛作为图床" class="headerlink" title="使用七牛作为图床"></a>使用七牛作为图床</h2><p>注册 <a href="https://portal.qiniu.com/signup?code=3liikw6nls3ma" target="_blank" rel="noopener">七牛账户</a> 并创建一个新的 bucket（选择华东区，否则下面提到的插件无法正常使用）， 利用插件 <a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="noopener">markdown-img-upload</a> 可以很方便地上传图片到七牛并插入图片引用到 Markdown 文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上把搭好的博客发给了我的 Best Gay Friend 看，本来只是想赚一下浏览量，但基友说也想搭一个类似的博客系统。 寻思着可以写一篇利用 Github Pages 搭建 Hexo 博客系统的入门教程，既可以增加一篇“凑字数”的博客，又可以急基友之所急。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://hiberabyss.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hiberabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 源文件备份</title>
    <link href="https://hiberabyss.github.io/2017/03/13/hexo-source-code-backup/"/>
    <id>https://hiberabyss.github.io/2017/03/13/hexo-source-code-backup/</id>
    <published>2017-03-13T05:00:26.000Z</published>
    <updated>2018-03-22T05:57:01.083Z</updated>
    
    <content type="html"><![CDATA[<p>在执行完 <code>hexo generate -d</code> 命令后会把生成的 html 文件上传到 github 上，我们还需要一种方法来备份源 markdown 文件及对应的 hexo 配置文件， 这样才能比较方便地在别的地方来生成对应的博客网站。对于这个备份机制会有以下几个需求：</p><a id="more"></a><h2 id="使用不同分支来分别保存博客源代码及生成的博客网站"><a href="#使用不同分支来分别保存博客源代码及生成的博客网站" class="headerlink" title="使用不同分支来分别保存博客源代码及生成的博客网站"></a>使用不同分支来分别保存博客源代码及生成的博客网站</h2><h3 id="使用-master-分支来保存生成的博客网站"><a href="#使用-master-分支来保存生成的博客网站" class="headerlink" title="使用 master 分支来保存生成的博客网站"></a>使用 master 分支来保存生成的博客网站</h3><p>因为 Github Page 要求使用 master 分支，我们便用 master 分支来保存生成的博客网站。 在装完 <code>hexo-deployer-git</code> 插件后，我们可以在 <code>_config.yml</code> 文件里添加如下的配置来指定博客的部署位置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:your-github-name/your-github-name.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后就可以使用 <code>hexo generate -d</code> 来基于你写的 markdown 文件来生成对应的博客网站，并部署到 github 上。</p><h3 id="使用-hexo-分支来保存博客源文件"><a href="#使用-hexo-分支来保存博客源文件" class="headerlink" title="使用 hexo 分支来保存博客源文件"></a>使用 hexo 分支来保存博客源文件</h3><p>在你的 Github Page Repository 里新建一个 hexo 分支，并把它设置成默认分支，这样以后打开这个 repository 的时候默认展示的就是这个分支里的内容。 需要把以下文件保存到 hexo 分支里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br></pre></td></tr></table></figure><p>其中 package.json 文件是为了在 clone 了博客源代码库之后可以很方便地通过 <code>npm install</code> 就能方便地生成 hexo 博客系统所依赖的所有包。 为了能在 package.json 里记录所有的包信息，需要在安装包时添加 <code>--save</code> 参数，例如：<code>npm install hexo-deployer-git --save</code>。</p><p>这篇<a href="http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/" target="_blank" rel="noopener">博客</a>有详细介绍如何通过不同分支来保存博客源文件及对应生成的博客网站文件。</p><h2 id="同时保存生成的网站文件及对应的源代码"><a href="#同时保存生成的网站文件及对应的源代码" class="headerlink" title="同时保存生成的网站文件及对应的源代码"></a>同时保存生成的网站文件及对应的源代码</h2><p><code>hexo-cli</code> 工具里有提供自动部署网站到 github 的功能，但并没有提供保存对应的源代码的机制，我们可以利用 git hook 来实现在部署网站时也自动 push 源代码 改动到 github。</p><p><code>hexo-cli</code> 是把对应的网站代码保存到 <code>/path/to/blog/.deploy_git</code> 这个 git repository 里，我们可以在这个 git 库里添加如下的 <code>pre-push</code> hook 来实现 部署网站时自动保存源代码到 hexo 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'Regular save'</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure><p>可以通过脚本的方式来自动地添加这个 <code>pre-hook</code>，具体怎么实现可以参考我写的这个<a href="https://github.com/hiberabyss/hiberabyss.github.io/blob/hexo/blog" target="_blank" rel="noopener">脚本</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在执行完 &lt;code&gt;hexo generate -d&lt;/code&gt; 命令后会把生成的 html 文件上传到 github 上，我们还需要一种方法来备份源 markdown 文件及对应的 hexo 配置文件， 这样才能比较方便地在别的地方来生成对应的博客网站。对于这个备份机制会有以下几个需求：&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://hiberabyss.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hiberabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>基于 Docker 搭建 Jenkins Pipeline 测试环境</title>
    <link href="https://hiberabyss.github.io/2017/03/12/jenkins-pipeline-tips/"/>
    <id>https://hiberabyss.github.io/2017/03/12/jenkins-pipeline-tips/</id>
    <published>2017-03-12T06:29:06.000Z</published>
    <updated>2017-09-14T03:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 CD 相关的一些工作，会用到 Jenkins Pipeline，为了方便测试，利用 Docker 搭建了一个本地的 Jenkins 服务。</p><a id="more"></a><h2 id="基于-docker-compose-建-Jenkins-container"><a href="#基于-docker-compose-建-Jenkins-container" class="headerlink" title="基于 docker-compose 建 Jenkins container"></a>基于 docker-compose 建 Jenkins container</h2><p>使用 <code>docker-compose</code> 可以很方便地创建并启动 container，下面是用于创建 Jenkins container 的 <code>docker-compose.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  jenkins:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">jenkinsci/blueocean:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">JAVA_OPTS=-Djenkins.install.runSetupWizard=false</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./jenkins_home:/var/jenkins_home</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./entrypoint.sh:/entrypoint.sh</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080:8080"</span></span><br></pre></td></tr></table></figure><p>其中 image 使用了预装了 <code>blue ocean</code> 插件的 <a href="https://hub.docker.com/r/jenkinsci/blueocean/" target="_blank" rel="noopener">jenkinsci/blueocean</a>。</p><p>通过把 <code>/var/jenkins_home</code> 映射到宿主机目录 <code>./jenkins_home</code> 来永久保存 Jenkins 的数据，当重启 Jenkins container 时， 类似创建的 Jenkins Job 之类的数据不会丢失。</p><p>默认的 Jenkins Container 每次启动时都会进行一遍初始化的操作，通过设置环境变量 <code>JAVA_OPTS=-Djenkins.install.runSetupWizard=false</code> 便可以防止这种行为。</p><p>通过端口映射 <code>8080:8080</code> 便可以直接在本地的 <code>8080</code> 端口访问到 container 内部的 Jenkins 服务。</p><h2 id="让-Jenkins-Job-自动加载修改后的-groovy-脚本"><a href="#让-Jenkins-Job-自动加载修改后的-groovy-脚本" class="headerlink" title="让 Jenkins Job 自动加载修改后的 groovy 脚本"></a>让 Jenkins Job 自动加载修改后的 groovy 脚本</h2><p>Jenkins 的 Pipeline 是基于 groovy 语言来实现的，为了方便测试，需要 Jenkins Job 能从本地 groovy 文件加载配置。 这可以通过 Jenkins 的 <code>load step</code> 来实现。</p><p>创建一个 Jenkins Job <code>CD-Test</code>，在它的 Pipeline 配置项里选择 <code>Pipeline script</code>，并填入以下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    load <span class="string">'../Jenkinsfile'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件夹 <code>/path/to/project/jenkins_home</code> 应该有这样的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workspace</span><br><span class="line">├── CD-Test</span><br></pre></td></tr></table></figure><p>通过硬连接的方式把 <code>Jenkinsfile</code> 脚本连接到 <code>workspace</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln /path/to/project/Jenkinsfile /path/to/project/jenkins_home/Jenkinsfile</span><br></pre></td></tr></table></figure><p>这样当你修改 <code>Jenkinsfile</code> 文件时，它会自动被 CD-Test 加载。</p><h2 id="使用-jenkins-cli-工具快速新建-Jenkins-build"><a href="#使用-jenkins-cli-工具快速新建-Jenkins-build" class="headerlink" title="使用 jenkins-cli 工具快速新建 Jenkins build"></a>使用 jenkins-cli 工具快速新建 Jenkins build</h2><p>通过 <code>jenkins-cli</code> 工具可以很方便地 实现创建一个 Jenkins Job 的 build、打开它最新的 build 等操作，下面是一个基于 <code>jenkins-cli</code> 的实用脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description: jenkins cli tool</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Author: Hongbo Liu</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Email: hbliu@freewheel.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CreatTime: 2017-03-10 17:43:58 CST</span></span><br><span class="line"></span><br><span class="line">export JENKINS_URL="http://localhost:8080"</span><br><span class="line">CLI_FILE="jenkins-cli.jar"</span><br><span class="line">JOBS_DIR="/Users/hbliu/gitlab/CICD/salt/jenkins_home/jobs"</span><br><span class="line"></span><br><span class="line">cd "$(dirname "$0")"</span><br><span class="line"></span><br><span class="line">if [[ ! -f jenkins-cli.jar ]]; then</span><br><span class="line">    wget "$JENKINS_URL/jnlpJars/jenkins-cli.jar"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">open_job_build() &#123;</span><br><span class="line">    local job_name="$1"</span><br><span class="line">    local url="$JENKINS_URL/blue/organizations/jenkins/$job_name/detail/$job_name"</span><br><span class="line"></span><br><span class="line">    local build_id=$(cat "$JOBS_DIR/$job_name/nextBuildNumber")</span><br><span class="line">    let build_id=build_id-1</span><br><span class="line"></span><br><span class="line">    shift 1</span><br><span class="line">    local OPT OPTARG OPTIND</span><br><span class="line">    while getopts 'rn:' OPT; do</span><br><span class="line">        case $OPT in</span><br><span class="line">            n) build_id=$OPTARG ;;</span><br><span class="line">            r)</span><br><span class="line">                main build $job_name</span><br><span class="line">                let build_id=build_id+1</span><br><span class="line">                ;;</span><br><span class="line">            ?) ;;</span><br><span class="line">        esac</span><br><span class="line">    done</span><br><span class="line">    shift $(($OPTIND - 1))</span><br><span class="line"></span><br><span class="line">    open "$url/$build_id"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    if [[ "$1" == "open" ]]; then</span><br><span class="line">        shift 1</span><br><span class="line">        open_job_build $*</span><br><span class="line">    else</span><br><span class="line">        java -jar $CLI_FILE $*</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main $*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做 CD 相关的一些工作，会用到 Jenkins Pipeline，为了方便测试，利用 Docker 搭建了一个本地的 Jenkins 服务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jenkins" scheme="https://hiberabyss.github.io/tags/jenkins/"/>
    
      <category term="CICD" scheme="https://hiberabyss.github.io/tags/cicd/"/>
    
  </entry>
  
  <entry>
    <title>为什么我开始尝试使用 Emacs</title>
    <link href="https://hiberabyss.github.io/2017/03/04/why-I-try-to-use-emacs/"/>
    <id>https://hiberabyss.github.io/2017/03/04/why-I-try-to-use-emacs/</id>
    <published>2017-03-05T03:46:54.000Z</published>
    <updated>2017-09-14T03:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为使用了四年多, 装了超过一百个插件的”资深” vim 用户, 最近开始尝试使用 Emacs. 做出这个决定主要是出于以下几个方面的考虑:</p><a id="more"></a><h2 id="Emacs-可以更方便地输入中文"><a href="#Emacs-可以更方便地输入中文" class="headerlink" title="Emacs 可以更方便地输入中文"></a>Emacs 可以更方便地输入中文</h2><p>打算以后都定期地写一些博客, 目前英文还太烂, 为了不打消写博客的积极性, 开始时还是写中文博客比较好. 但在 vim 里写中文的体验实在是太糟糕:</p><ul><li>在 <code>Insert</code> 模式下你需要使用中文输入法.</li><li>要执行 vim 的一些跳转等操作时你需要进入到 <code>Normal</code> 模式, 而这时你的按键会先被输入法获取, 没法直接执行 vim 的命令, 需要先把输入法切换到英文模式.</li><li>当执行完 vim 的操作, 重新进行编辑时, 你还需要把输入法再切换成中文.</li></ul><p>综上, 每次执行 vim 的操作你都需要切换两次输入法! 当然也有一些 vim 的插件, 如 OSX 下的 <a href="https://github.com/ybian/smartim.git" target="_blank" rel="noopener">SmartIM</a>, 可以帮助自动切换输入法, 但使用起来会经常有一些奇怪的问题, 例如会导致插件 VisIncr 变得极其缓慢.</p><p>相比于 vim, Emacs 就完全不会有这个问题, 因为它的命令操作都是和控制键绑定的, 而这些按键并不会被输入法截获, 所以就不会有 vim 的问题.</p><h2 id="使用-Orgmod"><a href="#使用-Orgmod" class="headerlink" title="使用 Orgmod"></a>使用 Orgmod</h2><p>早就听闻这个插件的大名, 一直想尝试下. Vim 下虽然也有类似的插件, 但目前都还只是半成品, 功能完全不能同日而语.</p><h2 id="传说中无所不能的-Emacs"><a href="#传说中无所不能的-Emacs" class="headerlink" title="传说中无所不能的 Emacs"></a>传说中无所不能的 Emacs</h2><p>传说 Emacs 无所不能, 比如直接浏览网页, 比如直接浏览 pdf 文件…</p><p>本来是想能在 Emacs 里变编辑 Markdown 文件, 变在另外一个窗口预览, 实现类似专业 Markdown 编辑器的功能, 但搜遍了 github 也没能找到这样一款称心如意的 Markdown 预览插件. 用 Emacs 自带窗口的预览效果奇丑无比, 不能忍! 推而求其次, 可以接受在第三方软件里显示效果, 然后把 Emacs 的编辑窗口设置成半透明来看实际效果. 但竟然都没能找到一款可以跟随 Emacs 编辑窗口里的光标自动 scroll 预览窗口内容的插件!!! 而我却找到了可以实现这样功能的 Vim 插件.</p><p>Emacs 也没有我最开始预想的那么无所不能…</p><h2 id="Elisp"><a href="#Elisp" class="headerlink" title="Elisp"></a>Elisp</h2><p>作为一名程序员, 现在如果没捣鼓过函数式编程语言, 就不好意思和别人说是科班出身的. Lisp 语言是最经典的函数式编程语言了, 而 Emacs 是用 lisp 作为它的插件编写语言, 学习 Emacs 也就可以顺便学习下 Lisp 了.</p><p>以上就是我开始学习 Emacs 的目的了. 学习 Emacs 这种和 Vim 完全不同操作模式、 不同设计理念的编辑器也可以开拓自己的视野， 或许将来可以进一步帮助自己提高 Vim 的使用效率。</p><p>最近的一段时间就会这样来使用 Vim 和 Emacs 了：</p><ul><li>Vim：依旧是主力编辑器，看代码，写代码；</li><li>Emacs：写博客，用 Orgmod 来记笔记和 Task 管理；</li></ul><p>这就是是我的第一篇正式博客了，晚安！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为使用了四年多, 装了超过一百个插件的”资深” vim 用户, 最近开始尝试使用 Emacs. 做出这个决定主要是出于以下几个方面的考虑:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Emacs" scheme="https://hiberabyss.github.io/tags/emacs/"/>
    
  </entry>
  
</feed>
